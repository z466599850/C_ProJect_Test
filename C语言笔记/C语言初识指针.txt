指针

    本章重点：
        1.指针是什么
        2.指针和指针类型
        3.野指针
        4.指针运算
        5.指针和数组
        6.二级指针
        7.指针数组
    指针是什么?
        在计算机科学中指针(Pointer)是编程语言中的一个对象，利用地址，它的值直接指向
        (pointsto)存在电脑存储器中另一个地方的值。由于通过地址能找到所需的变量单元，
        可以说，地址指向该变量单元。因此，将地址形象化的称为“指针”。意思是通过它能找到以它为地址
        的内存单元。
    指针
    指针是个变量，存放内存单元的地址(编号)
    代码：
    int main()
    {
        int a = 10;//在内存中开辟一块空间
        int* p = &a;//指针变量 指针：是存放变量地址的变量。如int* p =&a; 变量p的类型是int*，p的值是&a,也就是变量a的地址。
        //这里我们对变量a，取出它的地址，可以使用&操作符
        //将a的地址存放在p变量中，p就是一个指针变量
        return 0;
    }

    总结:指针就是变量，用来存放地址的变量。(存放在指针中的值都被当成地址处理)
    那这里的问题是
    ·一个小的单元到底是多大?(1个字节)
    ·如何编址?
    经过仔细的计算和权衡我们发现一个字节给一个对应的地址是比较合适的

    对于32位的机器，假设有32根地址线，那么假设每根地址线在寻址的是产生一个电信号正电/负电(.1或者0)

    那么32根地址线产生的地址就会是
        00000000 00000000 00000000 00000000
        00000000 00000000 00000000 00000001
        ...
        11111111 11111111 11111111 11111111

    这里就有2的32次方个地址
    每个地址标识一个字节，那我们就可以给232Byte==2^32/1024KB
    =2^32/1024/1024MB=-2^32/1024/1024/1024GB==4GB)4G的空闲进行编址

    同样的方法，那64位机器，如果给64根地址线，那能编址多大空间，自已计算。

    这里我们就明白:
       ·在32位的机器上，地址是32个0或者1组成二进制序列，那地址就得用4个字节的空间来存储，所
        以一个指针变量的大小就应该是4个字节。
       ·那如果在64位机器上如果有64个地址线，那一个指针变量的大小是8个字节，才能存放一个地址

    总结：
        ·指针是用来存放地址的，地址是唯一标示一块地址空间的
        ·指针的大小在32位平台是4个字节，在64位平台是8个字节






    指针和指针类型
        这里我们在讨论一下:指针的类型我们都知道，变量有不同的类型，整形，浮点型等。那指针有没有类
        型呢?准确的说:有的。

        当有这样的代码：
        int num = 10;
        p=&num;
        要将&num(num的地址)保存到p中，我们知道p就是一个指针变量，那它的类型是怎样的呢?我们
        给指针变量相应的类型
            char   *pc = NULL:
            int    *pi = NULL;
            short  *ps = NULL;
            long   *pl = NULL;
            float  *pf = NULL;
            dodtle *pd = NULL;
            这里可以看到，指针的定义方式是:type+。其实:char*类型的指针是为了存放char 类型变
            量的地址。short*类型的指针是为了存放short 类型变量的地址。 int*类型的指针是为了存放
            int类型变量的地址
            
        那指针类型的意义是什么?


         指针+-正数代码：

            int main()
            {
                int a = 0x11223344;
                int* pa = &a;
                char* pc = &a;
                printf("%p\n", pa);
                printf("%p\n", pa+1);//地址加了4

                printf("%p\n", pc);
                printf("%p\n", pc+1);//地址加了1
                return 0;
                //指针类型决定了:指针走一步走多远(指针的步长)
                    //int* p; p + 1 -- > 4
                    //char* p; p + 1-- > 1
                    //double* p; p + 1-- > 8
            }
            总结：指针的类型决定了指针向前或者向后走一步有多大(距离)






         指针的解引用代码：
            int main()
            {
                //printf("%d\n", sizeof(char*));
                //printf("%d\n", sizeof(short*));
                //printf("%d\n", sizeof(int*));
                //printf("%d\n", sizeof(double*));
                //因为我的是64位电脑所以打印出来的是8
                //如果是32位的电脑打印出来的就是4

                int a = 0x11223344;
                //int* pa = &a;
                //*pa = 0;
                char* pc = &a;
                *pc = 0;
                //printf("%p\n", pa);
                printf("%p\n", pc);
                return 0;
                //指针类型决定了指针进行解引用操作的时候，能够访问空间的大小
                //int* p; p能够访问4个字节
                //char* p; "p 能够访问1个字节
                //double* p;*p能够访问8个字节
            }

            int main()
            {
                int arr[10] = { 0 };
                //int* p = arr;//数组名-首元素的地址//这个是以4个字节4个字节的去改
                char* p = arr;//这个时候是一个字节一个字节的去改
                int i = 0;
                for (i = 0; i < 10; i++)
                {
                    *(p + i) = 1;
                }
                return 0;
            }


            总结:指针的类型决定了，对指针解引用的时候有多大的权限(能操作几个字节。比如:char”的
            指针解引用就只能访问一个字节而int的指针的解引用就能访问四个字节





            

        野指针：
        概念:野指针就是指针指向的位置是不可知的(随机的不正确的、没有明确限制的
        野指针成因
            1.指针末初始化

            int main()
            {
                int a;//局部变量不初始化，默认是随机值
                int* p;//局部的指针变量，就被初始化随机值
                *p= 20;//就是在系统中随机找一个地址把他的值改成20; 称为 野指针
                return 0;
            }

                 int main()
                {
                    //未初始化的指针变量
                    int* p;//局部变量不初始化，里边默认放的是一个随机值
                    *p = 20;//在内存随便找个地址把20放进去了 称为野地址  非法访问

                    return 0;
                }


            2.指针越界访问代码：

            int main()
            {
                int arr[10] = { 0 };
                int* p = arr;
                int i = 0;
                for (i = 0; i < 12; i++)
                {
                    //当指针指向的范围超出数组arr的范围时，p就是野指针
                    p++;
                }
                return 0;
            }

            //数组越界导致的野指针问题
            int main()
            {
                int a[10] = { 0 };
                int i = 0;
                int* p = a;
                for (i = 0; i <= 12; i++)
                {
                    //*p = i;
                    //p++;
                    *p++ = i;//这个和上面是一个意思相同，先使用 后++
                }
            }




            3.指针指向的空间释放
            这里放在动态内存开辟的时候讲解，这里可以简单提示一下

                int* test()
                {
                    int a = 10;
                    return &a;
                }
                int main()
                {
                    int* p = test();
                    *p = 20;
                    return 0;
                    //这个代码不行的哦
                    //这个房子已经还给卖房的人了，已经不能再住进去了
                }



                如何规避野指针：
                    1.指针初始化、
                    答：
                        int main()
                        {
                            int b = 0;//就跟这个变量一样 不知道放什么的时候就给个0
                            int a = 10;
                            int* pa = &a;
                            int* p = NULL;//NULL - 当不知道放什么时候的就用这个 - 用来初始化指针的，给指针赋值
                                            //NULL其实是0 只是强制类型转换了 ((void) 0)强制类型转换
                            return 0;
                        }
                    2.小心指针越界
                    答：一般越界都会程序崩溃的
                    3.指针指向空间释放即使置NULL
                    答：
                        int main()
                        {
                            int a = 10;
                            int* pa = &a;
                            *pa = 20;
                            //要是不想用他了
                            pa = NULL;//他没有指向任何的有效空间 //相当于是直接删除联系方式，撇清关系 高啊
                            //pa就和他们两清了
                            //pa是指针变量，存地址的，*pa是取地址里存的值 //加*时引用地址里的内容，不加时指指针本身
                            //*pa是解引用操作符，我们只是释放指针所以不需要加*号，如果加*号就相当于把int a 的值改成了NULL
                            //定义指针的时候需要加*，不定义的时候加*是取地址里面的值
                            return 0;
                        }
                    4.指针使用之前检查有效性


            指针运算
                · 指针+-整数
                · 指针-指针
                · 指针的关系运算

            代码：
                int main()
                {
                    int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
                    int i = 0;
                    int sz = sizeof(arr) / sizeof(arr[0]);
                    int* p = &arr[9];
                    /*for (i = 0; i < sz; i++)
                    {
                        printf("%d ", *p);// 1 2 3 4 5 6 7 8 9 10
                        p = p + 1;
                        //p++;
                        //p += 1;
                        //上面都是一样的
                    }*/
                    for (i = 0; i < 5; i++)
                    {
                        printf("%d ", *p);//10 8 6 4 2
                        p -= 2;
                    }
                    return 0;
                }

                代码2：
                    #define N_VALUES 5
                    int main()
                    {
                        float values[N_VALUES];
                        float* vp;
                        for (vp = &values[0]; vp < &values[N_VALUES];)
                        {
                            *vp++ = 0;	
                        }
                        return 0;
                    }

                

            指针-指针
            代码：
                int main()
                {
                    char ch[5] = { 0 };
                    int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
                    printf("%d",& arr[9] - &arr[0]);//指针减去指针 指针减去指针得到的是中间元素的个数  打印出来的是9
                                                    //想得到元素个数一定要大地址减小地址得到中间的个数;
                                                    //指针减指针一定要在他的空间去减

                    printf("%d", &arr[9] - &ch[0]); //千万不要去这样写//err 错误的写法
                    return 0;
                }



            代码2：
                int my_strlen(char* str)
                {
                    char* start = str;
                    char* end = str;
                    while (*end != '\0')
                    {
                        end++;
                    }
                    return end - start;
                }
                int main()
                {
                    //strlen - 求字符串长度
                    //递归- 模拟实现了strlen - 计数器的方式1 ， 递归的方式2
                    //
                    char arr[] = "bit";
                    int len = my_strlen(arr);
                    printf("%d\n", len);
                    return 0;
                }


        指针的关系运算符
        代码：
            #define N_VALUES 5
            int main()
            {
                float values[N_VALUES];
                float* vp;
                for (vp = &values[N_VALUES]; vp < &values[0];)
                {
                    *--vp = 0;	
                }
                return 0;
            }

        代码简化这将代码修改如下:!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

            代码2：
            #define N_VALUES 5
            int main()
            {
                float values[N_VALUES];
                float* vp;
                for (vp = &values[N_VALUES-1]; vp >= &values[0];v--)
                {
                    *vp = 0;
                }
                return 0;
            }

            实际在绝大部分的编译器上是可以顺利完成任务的，然而我们还是应该避免这样写，因为标准并不保证
            它可行。

        标准规定:
            允许指向数组元素的指针与指向数组最后一个元素后面的那个内存位置的指针比较，但是不允许
            与指向第一个元素之前的那个内存位置的指针进行比较。
        指针和数组
        数组名是什么？我们看一个例子
            int main()
            {
                int arr[10] = { 0 };
                printf("%p\n", arr);//地址 - 首元素的地址
                printf("%p\n", arr+1);
                printf("%p\n", &arr[0]);
                printf("%p\n", &arr[0]+1);
                printf("%p\n", &arr);// &数组名 取的是整个数组的地址
                printf("%p\n", &arr + 1);
                //1.&arr- &数组名 数组名不是首元素的地址-数组名表示整个数组  &数组名 取的是整个数组的地址
                //2.sizeof(arr) - sizeof(数组名) - 数组名表示的是整个数组 - sizeof(数组名)计算的是整个数组的大小

                return 0;
            }

            既然可以把数组名当成地址存放到一个指针中，我们使用指针来访问一个就成为可能
            int main()
            {
                int arr[10] = { 0 };
                int* p = arr;//p存放的是数组首元素的地址
                int i = 0;
                for (i = 0; i < 10; i++)
                {
                    *(p + i) = i;
                }
                for (i = 0; i < 10; i++)
                {
                    //printf("%d ", arr[i]);
                    printf("%d ", *(p + i));
                }
                return 0;
            }

        二级指针
        指针变量也是变量，是变量就有地址，那指针变量的地址存放在哪里?这就是三级指针

            int main()
            {
                int a = 10;
                int* pa = &a;//一级指针
                int* * ppa = &pa;//ppa二级指针// *ppa 意思是我是个指针变量 int*指的是ppa指项pa的类型是int*
                int*** pppa = &ppa;//三级指针
                **ppa = 20;
                printf("%d", **ppa);
                printf("%d", a);
            }
            a的地址存放在pa中，pa的地址存放在ppa中。pa是一级指针，而ppa是二级指针。

            指针数组
            //好孩子 -- 孩子
            //指针数组 - 数组 - 存放指针的数组
            //数组指针 - 指针
            int main()
            {
                int a = 10;
                int b = 20;
                int c = 30;
                //int* pa = &a;
                //int* pb = &b;
                //int* pc = &c;
                //整形数组
                //字符数组
                //指针数组
                int arr[10];
                int* arr2[3] = { &a,&b,&c };//指针数组
                int i = 0;
                for (i = 0; i < 3; i++)
                {
                    printf("%d ", *(arr2[i]));
                }
                return 0;
            }