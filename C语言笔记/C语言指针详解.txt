    指针的进阶
        1.字符指针
        2.数组指针
        3.指针数组
        4.数组传参和指针传参
        5.函数指针
        6.函数指针数组
        7.指向函数指针数组的指针
        8.回调函数
        9.指针和数组面试题的解析
    正文开始
        指针的主题，我们在初级阶段的《指针》章节已经接触过了，我们知道了指针的概念:
            1.指针就是个变量，用来存放地址，地址唯一标识一块内存空间。
            2.指针的大小是固定的4/8个字节 ( 32位平台/64位平台 )。
            3.指针是有类型，指针的类型决定了指针的+-整数的步长，指针解引用操作的时候的权限。
            4.指针的运算。
        这个章节，我们继续探讨指针的高级主题

    字符指针
        在指针的类型中我们知道有一种指针类型为字符指针 char*;

        int main()
        {
            char arr[10] = "abcdef";
            char* pc = arr;//放的是首元素的地址，然后pc通过这个首元素地址依次打印abcdef 直到\0才结束
            printf("%s\n", arr);//abcdef
            printf("%s\n", pc);//abcdef
            return 0;
        }



            int main()
            {
                const char* p = "abcdef";//"abcdef" 是一个常量字符串
                //*p = 'w';
                printf("%s\n", p);//这种写法是错误的不知道为什么能编译出来，
                //printf("%c\n", *p);//打印的是a 因为放的是首元素的地址 //指针P里放的不是字符串  是指针执行字符串首地址
                                    //%c是打印一个字符，p是首地址，所以要解引用。%s是打印字符串，字符串打印的时候从首地址开始一直到‘\0’结束
                //printf("%s\n", p);//abcdef //这里不用是因为*p从首地址取出指针指向的’a’，打印出a，p作为首地址打印字符串，直接打印一串，p是指针，*p是字符a
                return 0;
            }
            //网站:  www.stackoverflow.com
            //		 Segmentation fault	- 段错误 内存访问或非法访问
            //	


    上面代码的意思是把一个常量字符串的首字符h的地址存放到指针变量p中





            //曾经的一道笔试题 出自于一本书 《剑指offer》
            int main()
            {
                char arr1[] = "abcdef";
                char arr2[] = "abcdef";
                const char* p1 = "abcdef";//加上const就是这个不能被更改
                const char* p2 = "abcdef";//加上const就是这个不能被更改
                if (p1 == p2)//这里p1和p2字符相同为了节省空间存储的是一个位置 //hehe，这是因为*p内存的首地址，p指向的是abcdef 
                                                        //两个指针都没有指向数组，他们指向的是abcdef这个字符串常量
                {
                    printf("hehe\n");
                }
                else
                {
                    printf("haha\n");
                }
                /*if (arr1 == arr2)//虽然arr1和arr2一样但是存储的地址不一样 所以他就不能够相等
                {
                    printf("hehe\n");
                }
                else
                {
                    printf("haha\n");
                }*/
                return 0;
            }

            这里p1和p2指向的是一个同一个常量字符串。C/C++会把常量字符串存储到单独的一个内存区域，
            当几个指针。指向同一个字符串的时候，他们实际会指向同一块内存。但是用相同的常量字符串去初始
            化不同的数组的时候就会开辟出不同的内存块。所以arr1和arr2不同，p1和p2不同










    指针数组

                //指针数组 是数组，用来存放指针的
                int main()
                {
                    int arr[10] = { 0 };//整型数组
                    char ch[5] = { 0 };//字符数组
                    int* parr[4];//存放整型指针的数组 - 指针数组
                    char* pch[5];//存放字符指针的数组 - 指针数组
                    return 0;
                }

                //指针数组的用法
                int main()
                {
                    int arr1[] = { 1,2,3,4,5,6 };
                    int arr2[] = { 2,3,4,5,6,7 };
                    int arr3[] = { 3,4,5,6,7,8 };

                    int* parr[] = { arr1,arr2,arr3 };
                    int i = 0;
                    for (i = 0; i < 3; i++)
                    {
                        int j = 0;
                        for (j = 0; j < 6; j++)
                        {
                            printf("%d ", *(parr[i] + j));
                        }
                        printf("\n");
                    }
                    return 0;
                }







        数组指针：

            数组指针的定义

            数组指针是指针?还是数组?
            答案是:指针。

            我们已经熟悉:整形指针: int* pint;能够指向整形数据的指针。浮点型指针:float* pf能够
            指向浮点型数据的指针。

            那数组指针应该是:能够指向数组的指针

            下面代码哪个是数组指针?
            int *p1[10];
            int (*p2)[10];
            //p1,p2分别是什么

                //数组指针 - 指针
                int main()
                {
                    //int* p = NULL;//p是整形指针 - 指向整形的指针 - 可以存放整形的地址
                    //char* pc = NULL;//pc是字符指针 - 指向字符的指针 - 可以存放字符的地址
                    //					//数组指针 - 指向数组的指针 - 可以存放数组的地址
                    //int arr[10] = { 0 };
                    //arr - 首元素地址
                    //&arr[0] - 首元素的地址
                    //&arr - 数组的地址
                    int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
                    int(*p)[10] = &arr;//数组的地址要存起来
                    //上面p就是数组指针
                    printf("%d ", p);
                    return 0;
                }


        那我就出一道题喽

            int main()
            {
                char* arr[5];
                char* (*pa)[5] = &arr;//写出上面代码的数组指针的写法

                int arr2[5] = { 0 };
                int (*pa2)[5] = &arr2;
                return 0;
            }





        数组指针的用法：

            //数组指针的使用：
            //参数是数组的形式
            void print1(int arr[3][5], int x,int y)
            {
                int i = 0;
                int j = 0;
                for (i = 0; i < x; i++)
                {
                    for (j = 0; j < y; j++)
                    {
                        printf("%d ", arr[i][j]);
                    }
                    printf("\n");
                }
            }

            //参数是指针的形式
            void print2(int(*p)[5],int x,int y)
            {
                int i = 0;
                for (i = 0; i < x; i++)
                {
                    int j = 0;
                    for (j = 0; j < y; j++)
                    {
                        printf("%d ", p[i][j]);//这几种写法也是一样的
                        //printf("%d ", *(p[i] + j));
                        //printf("%d ", ( * (p + i))[j]);
                        //printf("%d ", *(*(p + i) + j));//好像懂了，这里p是第一行整个数组的地址，*p是第一行首元素地址，
                                                        //p+i每次地址加一行，*（p+i）是该行首元素地址，+j是该行第几个元素
                                                        //第二种解释方法 *（p+1）是行地址，(*(p+i)+j)是行列地址，*(*(p+i)+j)是解引用的数组元素值
                                                //p是指第一行整个地址，*p是指第一行第一个元素地址
                    }
                    printf("\n");
                }
            }
            int main()
            {
                int arr[3][5] = { {1,2,3,4,5},{2,3,4,5,6},{3,4,5,6,7} };
                print1(arr,3,5);//arr - 数组名 - 数组名就是首元素地址
                print2(arr, 3,5);//arr 数组传参传的是首元素的地址，然后在二维数组里面每一行代表一个元素，所以arr有3个元素。
                //int arr[10] = { 1,2,3,4,5,6,7,8,9,10};
                //int* p = arr;
                //int i = 0;
                //for (i = 0; i < 10; i++)
                //{
                //	//printf("%d ", p[i]);//这几种写法都是等价的
                //	//printf("%d ", *(p + i));
                //	printf("%d ", *(arr + i));
                //	printf("%d ", arr[i]);//arr[i] == *(arr+i) == *(p+i) == p[i]
                //}
                return 0;
            }
            











        数组指针和指针数组的区别

            数组指针（也称行指针）

            定义 int (*p)[n];
            ()优先级高，首先说明p是一个指针，指向一个整型的一维数组，这个一维数组的长度是n，也可以说是p的步长。也就是说执行p+1时，p要跨过n个整型数据的长度。
            如要将二维数组赋给一指针，应这样赋值：
            int a[3][4];
            int (*p)[4]; //该语句是定义一个数组指针，指向含4个元素的一维数组。
            p=a;        //将该二维数组的首地址赋给p，也就是a[0]或&a[0][0]
            p++;       //该语句执行过后，也就是p=p+1;p跨过行a[0][]指向了行a[1][]

            所以数组指针也称指向一维数组的指针，亦称行指针。

            指针数组

            定义 int *p[n];
            []优先级高，先与p结合成为一个数组，再由int*说明这是一个整型指针数组，它有n个指针类型的数组元素。这里执行p+1时，则p指向下一个数组元素，这样赋值是错误的：p=a；因为p是个不可知的表示，只存在p[0]、p[1]、p[2]...p[n-1],而且它们分别是指针变量可以用来存放变量地址。但可以这样 *p=a; 这里*p表示指针数组第一个元素的值，a的首地址的值。
            如要将二维数组赋给一指针数组:
            int *p[3];
            int a[3][4];
            p++; //该语句表示p数组指向下一个数组元素。注：此数组每一个元素都是一个指针
            for(i=0;i<3;i++)
            p[i]=a[i]
            这里int *p[3] 表示一个一维数组内存放着三个指针变量，分别是p[0]、p[1]、p[2]
            所以要分别赋值。

            这样两者的区别就豁然开朗了，数组指针只是一个指针变量，似乎是C语言里专门用来指向二维数组的，它占有内存中一个指针的存储空间。指针数组是多个指针变量，以数组形式存在内存当中，占有多个指针的存储空间。
            还需要说明的一点就是，同时用来指向二维数组时，其引用和用数组名引用都是一样的。
            比如要表示数组中i行j列一个元素：
            *(p[i]+j)、*(*(p+i)+j)、(*(p+i))[j]、p[i][j]

            优先级：()>[]>*


            一、指针数组和数组指针的内存布局
            初学者总是分不出指针数组与数组指针的区别。其实很好理解：
            指针数组：首先它是一个数组，数组的元素都是指针，数组占多少个字节由数组本身的大小决定，每一个元素都是一个指针，在32 位系统下任何类型的指针永远是占4 个字节。它是“储存指针的数组”的简称。
            数组指针：首先它是一个指针，它指向一个数组。在32 位系统下任何类型的指针永远是占4 个字节，至于它指向的数组占多少字节，不知道，具体要看数组大小。它是“指向数组的指针”的简称。

            下面到底哪个是数组指针，哪个是指针数组呢：
            A)
            int *p1[10];
            B)
            int (*p2)[10];
            每次上课问这个问题，总有弄不清楚的。这里需要明白一个符号之间的优先级问题。

            “[]”的优先级比“*”要高。p1 先与“[]”结合，构成一个数组的定义，数组名为p1，int *修饰的是数组的内容，即数组的每个元素。那现在我们清楚，这是一个数组，其包含10 个指向int 类型数据的指针，即指针数组。至于p2 就更好理解了，在这里“（）”的优先级比“[]”高，“*”号和p2 构成一个指针的定义，指针变量名为p2，int 修饰的是数组的内容，即数组的每个元素。数组在这里并没有名字，是个匿名数组。那现在我们清楚p2 是一个指针，它指向一个包含10 个int 类型数据的数组，即数组指针。我们可以借助下面的图加深理解：

            二、int (*)[10] p2-----也许应该这么定义数组指针
            这里有个有意思的话题值得探讨一下：平时我们定义指针不都是在数据类型后面加上指针变量名么？这个指针p2 的定义怎么不是按照这个语法来定义的呢？也许我们应该这样来定义p2：
            int (*)[10] p2;
            int (*)[10]是指针类型，p2 是指针变量。这样看起来的确不错，不过就是样子有些别扭。其实数组指针的原型确实就是这样子的，只不过为了方便与好看把指针变量p2 前移了而已。你私下完全可以这么理解这点。虽然编译器不这么想。^_^
            三、再论a 和&a 之间的区别
            既然这样，那问题就来了。前面我们讲过a 和&a 之间的区别，现在再来看看下面的代码：
            int main()
            {
            char a[5]={'A','B','C','D'};
            char (*p3)[5] = &a;
            char (*p4)[5] = a;
            return 0;
            }
            上面对p3 和p4 的使用，哪个正确呢？p3+1 的值会是什么？p4+1 的值又会是什么？毫无疑问，p3 和p4 都是数组指针，指向的是整个数组。&a 是整个数组的首地址，a是数组首元素的首地址，其值相同但意义不同。在C 语言里，赋值符号“=”号两边的数据类型必须是相同的，如果不同需要显示或隐式的类型转换。p3 这个定义的“=”号两边的数据类型完全一致，而p4 这个定义的“=”号两边的数据类型就不一致了。左边的类型是指向整个数组的指针，右边的数据类型是指向单个字符的指针。在Visual C++6.0 上给出如下警告：
            warning C4047: 'initializing' : 'char (*)[5]' differs in levels of indirection from 'char *'。
            还好，这里虽然给出了警告，但由于&a 和a 的值一样，而变量作为右值时编译器只是取变量的值，所以运行并没有什么问题。不过我仍然警告你别这么用。

            既然现在清楚了p3 和p4 都是指向整个数组的，那p3+1 和p4+1 的值就很好理解了。

            但是如果修改一下代码，把数组大小改小点，会有什么问题？p3+1 和p4+1 的值又是多少呢？
            int main()
            {
            char a[5]={'A','B','C','D'};
            char (*p3)[3] = &a;
            char (*p4)[3] = a;
            return 0;
            }

            甚至还可以把代码再修改，把数组大小改大点：
            int main()
            {
            char a[5]={'A','B','C','D'};
            char (*p3)[10] = &a;
            char (*p4)[10] = a;
            return 0;
            }
            这个时候又会有什么样的问题？p3+1 和p4+1 的值又是多少？

            上述几个问题，希望读者能仔细考虑考虑，并且上机测试看看结果。

            测试结果:
            (1).char (*p2)[5]=a;必须使用强制转换,如:char (*p2)[5]=(char (*)[5])a;
            (2).把数组大小改变,都会编译不通过,提示:
            error C2440: 'initializing' : cannot convert from 'char (*)[5]' to 'char (*)[3]'
            error C2440: 'initializing' : cannot convert from 'char (*)[5]' to 'char (*)[10]'

            (3).把以上程序测试代码如下:
            int main()
            {
            char a[5]={'a','b','c','d'};
            char (*p1)[5]= &a;
            char (*p2)[5]=(char (*)[5])a;

            printf("a=%d\n",a);
            printf("a=%c\n",a[0]);
            printf("p1=%c\n",**p1);
            printf("p2=%c\n",**p2);
            printf("p1+1=%c\n",**(p1+1));
            printf("p2+1=%c\n",**(p2+1));

            return 0;
            }

            输出:
            a=1638208
            a=a
            p1=a
            p2=a
            p1+1=?
            p2+1=?
            Press any key to continue

            结论:
            根据指针类型及所指对象,表示指针大小,每次加1,表示增加指针类型大小的字节.----后面还会有解释说明.
            四、地址的强制转换
            先看下面这个例子：
            struct Test
            {
            int Num;
            char *pcName;
            short sDate;
            char cha[2];
            short sBa[4];
            }*p;

            假设p 的值为0x100000。如下表表达式的值分别为多少？
            p + 0x1 = 0x___ ?
            (unsigned long)p + 0x1 = 0x___?
            (unsigned int*)p + 0x1 = 0x___?
            我相信会有很多人一开始没看明白这个问题是什么意思。其实我们再仔细看看，这个知识点似曾相识。一个指针变量与一个整数相加减，到底该怎么解析呢？

            还记得前面我们的表达式“a+1”与“&a+1”之间的区别吗？其实这里也一样。指针变量与一个整数相加减并不是用指针变量里的地址直接加减这个整数。这个整数的单位不是byte 而是元素的个数。所以：p + 0x1 的值为0x100000+sizof（Test）*0x1。至于此结构体的大小为20byte，前面的章节已经详细讲解过。所以p +0x1 的值为：0x100014。

            (unsigned long)p + 0x1 的值呢？这里涉及到强制转换，将指针变量p 保存的值强制转换成无符号的长整型数。任何数值一旦被强制转换，其类型就改变了。所以这个表达式其实就是一个无符号的长整型数加上另一个整数。所以其值为：0x100001。

            (unsigned int*)p + 0x1 的值呢？这里的p 被强制转换成一个指向无符号整型的指针。所以其值为：0x100000+sizof（unsigned int）*0x1，等于0x100004。

            上面这个问题似乎还没啥技术含量，下面就来个有技术含量的：在x86 系统下，其值为多少？
            intmain()
            {
            int a[4]={1,2,3,4};
            int *ptr1=(int *)(&a+1);//指向a数组后面的内存单元，&a+1表示向后移16个存储单元
            int *ptr2=(int *)((int)a+1);//表示a的存储单元的地址增加一个字节
            printf("%x,%x",ptr1[-1],*ptr2);//ptr1[-1]其实指向的是a数组的最后一个单元，*ptr1则表示a数组的地址后移一个字节之后的4个连续存储单元所存储的值
            return 0;
            }
            这是我讲课时一个学生问我的题，他在网上看到的，据说难倒了n 个人。我看题之后告诉他，这些人肯定不懂汇编，一个懂汇编的人，这种题实在是小case。下面就来分析分析这个问题：

            根据上面的讲解，&a+1 与a+1 的区别已经清楚。

            ptr1：将&a+1 的值强制转换成int*类型，赋值给int* 类型的变量ptr，ptr1 肯定指到数组a 的下一个int 类型数据了。ptr1[-1]被解析成*(ptr1-1)，即ptr1 往后退4 个byte。所以其值为0x4。
            ptr2：按照上面的讲解，(int)a+1 的值是元素a[0]的第二个字节的地址。然后把这个地址强制转换成int*类型的值赋给ptr2，也就是说*ptr2 的值应该为元素a[0]的第二个字节开始的连续4 个byte 的内容。

            其内存布局如下图：

            好，问题就来了，这连续4 个byte 里到底存了什么东西呢？也就是说元素a[0],a[1]里面的值到底怎么存储的。这就涉及到系统的大小端模式了，如果懂汇编的话，这根本就不是问题。既然不知道当前系统是什么模式，那就得想办法测试。大小端模式与测试的方法在第一章讲解union 关键字时已经详细讨论过了，请翻到彼处参看，这里就不再详述。我们可以用下面这个函数来测试当前系统的模式。
            int checkSystem()
            {
            union check
            {
                int i;
                char ch;
            } c;
            c.i = 1;
            return (c.ch ==1);//如果当前系统为大端模式这个函数返回0；如果为小端模式，函数返回1。
            }

            如果当前系统为大端模式这个函数返回0；如果为小端模式，函数返回1。也就是说如果此函数的返回值为1 的话，*ptr2 的值为0x2000000。如果此函数的返回值为0 的话，*ptr2 的值为0x100。









            学了指针数组和数组指针我们来一起回顾并看看下面代码的意思！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！

                int arr[5];//数组名是arr，数组有五个元素，每个元素的类型是int

                int *parr1[10];//数组名是parr1，数组有10个元素，每个元素的类型是int*

                int (*parr2)[10];//*parr2是一个指针，该指针指向了一个数组，数组有10个元素，指针数组指的里面每个元素的类型是int

                int (*p[10])[5;]//p是一个数组，该数组有10个元素，每个元素是一个数组指针
                                //该数组指针指向的数组有5个元素，每个元素的类型是int 意思是数组指针有10个元素 这10个元素每个元素有五个元素









            回顾一下上节课讲的东西：

                int main()
                {
                    char* ch = 'w';
                    char* p = &ch;
                    const char* p2 = "abcdef";//要知道指针是4个字节怎么能存放这么多呢 当然存的是首元素的地址 通过首元素的地址就能找到abcdef
                                            //abcdef是个常量字符串，当然不允许被修改 加个const 就是不被修改了
                    //指针数组 - 存放指针的数组
                    int* arr[10];
                    char* ch[5];
                    //数组指针 - 指向数组
                    //int* p3;//整形指针 - 指向整形的指针
                    //char* p4;//字符指针 - 指向字符的
                    int arr2[5];//数组
                    int(*pa)[5] = &arr2;//取出数组的地址，pa就是一个数组指针 //一般情况下是去掉变量名 就是他的类型
                    return 0;
                }

            数组参数、指针参数
            
            在写代码的时候难免要把[数组]或者[指针]传给函数，那函数的参数该如何设计呢?



            一维数组传参
                //一维数组传参
                void test(int arr[])
                {}
                void test1(int arr[10])
                {}
                void test2(int *arr)
                {}
                void test3(int *arr[2])
                {}
                void test5(int *arr)
                {}
                int main()
                {
                    int arr[10] = { 0 };
                    int* arr1[2] = { 0 };
                    test(arr);
                    test1(arr);
                    test2(arr);
                    test3(arr1);
                    test5(arr1);
                    return 0;
                }





            二维数组传参

                //二维数组传参

                void test(int arr[3][5])
                {}
                void test1(int arr[][5])
                {}
                //void test2(int arr[3][])//err 错误的
                //{}
                //void test3(int *arr)//err
                //{}
                //void test4(int* arr[5])//err
                //{}
                void test5(int (*arr)[5])
                {}
                //void test6(int **arr)//err
                //{}
                int main()
                {
                    int arr[3][5] = { 0 };
                    test(arr);
                    test1(arr);
                    //test2(arr);
                    //test3(arr);
                    //test4(arr);
                    test5(arr);
                    //test6(arr);
                    return 0;
                }





            一级数组传参
                //一级数组传参
                void print(int* p, int sz)
                {
                    int i = 0;
                    for (i = 0; i < sz; i++)
                    {
                        printf("%d ", i);
                    }
                }

                int main()
                {
                    int arr[] = { 1,2,3,4,5,6,7,8,9,10 };
                    int* p = arr;
                    int sz = sizeof(arr) / sizeof(arr[0]);
                    print(p, sz);//传参
                    return 0;
                }





        那我们来思考一个问题：

                //思考:当一个函数的参数部分为一级指针的时候，函数能接收什么参数?
                void test1(int *p)
                {}
                void test2(char *p)
                {}
                int main()
                {
                    int a = 10;
                    int* pa = &a;
                    test1(&a);//ok
                    test1(pa);//ok

                    char  ch = 'w';
                    char* pc = &ch;
                    test2(&ch);
                    test2(pc);
                    return 0;
                }





        二级数组传参
                //二级指针传参
                void test(int** p)
                {}

                int main()
                {
                    int n = 10;
                    int* p = &n;
                    int** pp = &p;
                    test(pp);//ok
                    test(&p);//ok
                    return 0;
                }





            //思考:当函数的参数为二级指针的时候，可以接收什么参数?
            void test(char** p)
            {
            }

            int main()
            {
                char c = 'w';
                char* pc = &c;
                char** pcc = &pc;
                char arr[10];
                test(&pc);//ok
                test(pcc);//ok
                test(arr);//指针数组也可以
                return 0;
            }








         函数指针

                //函数指针
                //数组指针 - 是指向数组的指针
                //函数指针 - 是指向函数的指针 - 存放函数地址的一个指针
                int Add(int x, int y)
                {
                    int z = 0;
                    z = x + y;
                    return z;
                }
                int main()
                {
                    int a = 10;
                    int b = 20;
                    //int arr[10] = { 0 };
                    //int(*pa)[10] = &arr;	
                    //printf("%d\n", Add(a, b));

                    //&函数名 和 函数名 都是函数的地址
                    //printf("%p\n", &Add);//函数邮有地址
                    //printf("%p\n", Add);//跟上面的并没有太大的区别

                    int(*pa)(int, int) = Add;//函数指针
                    printf("%d ", (*pa)(2, 3));
                    return 0;
                }


        输出的是两个地址，这两个地址是 test 函数的地址。那我们的函数的地址要想保存起来，怎么保存?
        下面我们看代码:

                void test()
                {
                    printf("hehe\n");
                }
                //下面pfun1和pfun2哪个有能力存放test函数的地址?
                void (*pfun1)
                void *pfun2()
                首先，能给存储地址，就要求pfun1或者pfun2是指针，那哪个是指针?答案是:
                pfun1可以存放。pfun1先和*结合，说明pfun1是指针，指针指向的是一个函数，指向的函数无
                参数返回值类型为void

        补充：

            void Print(char* str)
            {
                printf("%s\n", str);
            }

            int main()
            {
                void (*pa)(char*) = Print;//char* 是因为 形参是char* 
                (*pa)("hello bit");
                return 0;
            }



        阅读两段有趣的代码:  有可能会出考试题 

        //代码1

        void(*)() - 函数指针类型

        (*(void(*)()0))();
        (*(  void(*)()   ) 0)  ();
        //把0强制类型转换成：void(*)() 函数指针类型 - 0就是一个函数的地址
        //调用0地址处的该函数  代码来自一本书 《C陷阱和缺陷》
        //函数调用

        //代码2
        //signal;是一个函数声明，
        // signal函数的参数有2个，第一个是int类型，第二个是函数指针，该函数指针指向的函数int 返回类型是void
        // signal函数返回类型也是一个函数指针。该函数指针指向的是int，返回类型是void
        //代码2：
        void(*signal(int, void(*)(int)))(int);

        //简化
        typedef void(*pfun_t)(int);//typedef 修改函数名 用typedef函数指针是这样修改的哦
        pfun_t signal(int, pfun_t);

        //其他的是这样修改的
        typedef unsigned int unit;



    函数指针的补充：
        //补充
        int Add(int x, int y)
        {
            int z = 0 ;
            return z = x+y;
        }

        int main()
        {
            int a = 0;
            int b = 0;
            int(*pa)(int, int) = Add;
            printf("%d\n", pa(2, 3));
            printf("%d\n", Add(2, 3));
            printf("%d\n", (*pa)(2, 3));//这里的*号 多此一举
            //这三种的写法都一样 等价的
            return 0;
        }


    函数指针数组：
        数组是一个存放相同类型数据的存储空间，那我们已经学习了指针数组，比如
            int *arr[10];
            //数组的每个元素是int*

        那要把函数的地址存到一个数组中，那这个数组就叫函数指针数组，那函数指针的数组如何定义呢?
           int (*parr[4])(int,int)={NULL,NULL,NULL,NULL}

        看一下下面的例子：
            //函数指针数组
            int Add(int x, int y)
            {
                return x + y;
            }
            int Sub(int x, int y)
            {
                return x - y;
            }
            int Mul(int x, int y)
            {
                return x * y;
            }
            int Div(int x, int y)
            {
                return x / y;
            }
            int main()
            {
                int a = 0;
                int b = 0;
                //int(*p)(int, int) = Add;//如果要调用4个函数类型，你该怎么调用呢
                int(*parr[4])(int, int) = { Add,Sub,Mul,Div };//函数指针数组
                int i = 0;
                for (i = 0; i < 4; i++)//使用循环去算出函数指针数组的值
                {
                    printf("%d\n", parr[i](2,3));//(x,y)输入值去算出 得出 5  -1  6  0
                }
                return 0;
            }




        函数指针数组的用途:转移表

        例子:(计算器)

                //设计 计算器
                void menu()
                {
                    printf("*****************************\n");
                    printf("****** 1.Add 	2.Sub *******\n");
                    printf("*******3.Mul	4.Div *******\n");
                    printf("*******	    0.quit    *******\n");
                }

                int Add(int x,int y)
                {
                    return x + y;
                }

                int Sub(int x, int y)
                {
                    return x - y;
                }

                int Mul(int x, int y)
                {
                    return x * y;
                }
                int Div(int x, int y)
                {
                    return x / y;
                }



                /*//函数指针数组写法
                int main()
                {
                    int x = 0;
                    int y = 0;
                    int input = 0;
                    int(*pfarr[5])(int, int) = { 0,Add,Sub,Mul,Div };
                    do
                    {
                        menu();
                        printf("请选择:>");
                        scanf("%d", &input);
                        if (input >= 1 && input <= 4)
                        {
                            printf("请输入两个操作数:>");
                            scanf("%d%d", &x, &y);
                            int ret = pfarr[input](x, y);
                            printf("%d\n", ret);
                        }
                        else if (input == 0)
                        {
                            printf("退出\n");
                            break;
                        }
                        else
                        {
                            printf("选择错误\n");
                            break;
                        }
                    } while (input);


                    return 0;
                }*/


                //switch 简化版的写法
                void Calc(int(*pca)(int, int))
                {
                    int x = 0;
                    int y = 0;
                    printf("请选择两个操作数:>");
                    scanf_s("%d%d", &x, &y);
                    printf("ret = %d\n", pca(x, y));
                }

                int main()
                {
                    int input = 0;
                    do
                    {
                        menu();
                        printf("请选择:>");
                        scanf_s("%d", &input);
                        switch (input)
                        {
                        case 1:
                            Calc(Add);
                        case 2:
                            Calc(Sub);
                        case 3:
                            Calc(Mul);
                        case 4:
                            Calc(Div);
                        case 0:
                            printf("退出\n");
                        default:
                            printf("输入错误\n");
                        }
                    } while (input);
                    return 0;
                }


                /*//switch 语句的写法
                int main()
                {
                    int input = 0;
                    int x = 0;
                    int y = 0;
                    do
                    {
                        menu();
                        printf("请选择:>");
                        scanf("%d", &input);
                        printf("请选择两个操作数:>");
                        scanf("%d%d", &x, &y);
                        switch (input)
                        {
                        case 1:
                            printf("%d\n", Add(x, y));
                            break;
                        case 2:
                            printf("%d\n", Sub(x, y));
                            break;
                        case 3:
                            printf("%d\n", Mul(x, y));
                            break;
                        case 4:
                            printf("%d\n", Div(x, y));
                            break;
                        case 0:
                            printf("退出\n");
                        default:
                            printf("输入错误\n");

                        }
                    } while (input);
                    return 0;
                }*/











            //练习
            char* my_strcpy(char* dest, const char* src);


            int main()
            {
                //根据以上的形参写出以下题目：
                //1.写一个函数指针pf，能够指向my_strcpy
                char* (*pf)(char*,const char*) = my_strcpy;//函数指针,指向的是my_strcpy
                //2.写一个函数指针数组，能够存放4个my_strcpy函数的地址
                char* (*pff[4])(char*, const char*) = {0,0,0,0,};//函数指针数组
                return 0;
            }






         指向函数指针数组的指针
         指向函数指针数组的指针是一个指针指针指向一个数组，数组的元素都是函数指针

         如何定义?
            int Add(int x, int y)
            {
                return x + y;
            }
            int main()
            {
                int arr[10] = { 0 };
                int (* p)[10] = &arr;//取出数组的地址

                int(*pf)(int, int);//函数指针
                int(*pfArr[4])(int, int);//函数指针数组 pfArr是一个数组-函数指针的数组
                //ppfArr是一个指向 [函数指针数组的] 指针
                int(*(*ppfArr)[4])(int, int) = &pfArr;// 指向函数指针数组的指针 注：一般情况下去掉数组名 或变量名就是他的类型
                //
                //ppfArr 是一个数组指针，指针指向的数组有4个元素
                //指向的数组的每个元素的类型是一个函数指针 类型是 int(*)(int,int)
                // 未来能够用到还是两回事
                return 0;
            }


        回顾一下上节课讲的东西：
                //回顾上节课的内容
                int Add(int x, int y)
                {
                    return x + y;
                }

                int main()
                {
                    //指针数组
                    //int* arr[10];
                    //数组指针
                    //int (*pa)[10] = &arr;
                    //函数指针
                    int (*pAdd)(int, int) = Add;
                    //int sum = (*pAdd)(2, 3);//函数指针调用
                    //int sum = pAdd(2, 3);//两种写法
                    //printf("sum = %d", sum);
                    //函数指针的数组
                    int(*pArr[5])(int, int);
                    //指向函数指针数组的指针
                    int(*(*ppArr)[5])(int, int);
                    return 0;
                }



         回调函数
            回调函数就是一个通过函数指针调用的函数。如果你把函数的指针(地址)作为参数传递给另一
            个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该
            函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或
            条件进行响应。

            首先演示一下qsort函数的使用:    

                用法qsort(第一个数组起始位置，第二个几个元素，每个元素的大小，创建函数进行比较)

                    //补充void的用法：
                    int main()
                    {
                        int a = 10;
                        void* p = &a;

                        //void* 类型的指针 可以接受任意类型的地址
                        //void* 类型的指针 不能进行解引用操作 要用的话要强制类型转换
                        //void* 类型的指针 不能进行+-整数的操作
                        return 0;
                    }




                    //qsort 第一个参数：待排序数组的首元素地址
                    //		第二个参数：待排序数组的元素个数
                    //		第三个参数：待排序数组的每个元素的大小-单位是字节
                    //		第四个参数：是函数指针，比较两个元素的所用函数的地址-这个函数使用者实现
                            //int arr[]={1,2,3};
                            //int sz = sizeof(arr) / siezoef(arr[0]);//计算元素个数
                    //例子：qsort(首元素地址，元素个数，每个元素的字节是多少，函数指针);





                    //qsort 的用法qsort(第一个数组起始位置，第二个几个元素，每个元素的大小，创建函数进行比较)
                    // 
                    //名字排序的方法
                    struct Stu
                    {
                        char name[20];
                        int age;
                    };


                    int cmp_s_name(const void* e1, const void* e2)
                    {
                        //比较名字就是比较字符串
                        // 字符串比较不能直接用 > <= 来比较，应该用strcmp函数
                        //strcmp比较是通过比较ASCII表 头文件是 string
                        //strlen不可以，那个是字符串长度，不一样的，这个是看字母对应的ASCII码的大小
                        //就是首字母的ascii码值 z  l  w
                        return strcmp(((struct Stu*)e1)->name,((struct Stu*)e2)->name);
                    }


                    int main()
                    {
                        struct Stu s[3] = { {"zhangsan",20},{"lisi",30},{"wangwu",10} };
                        int sz = sizeof(s) / sizeof(s[0]);
                        qsort(s, sz, sizeof(s[0]), cmp_s_name);
                        return 0;
                    }

                    /*//年龄排序的方法
                    struct Stu
                    {
                        char name[20];
                        int age;
                    };


                    int cmp_s_age(const void* e1, const void* e2)
                    {
                        return ((struct Stu*)e1)->age - ((struct Stu*)e2)->age;
                    }


                    int main()
                    {
                        struct Stu s[3] = { {"zhangsan",20},{"lisi",30},{"wangwu",10}};
                        int sz = sizeof(s) / sizeof(s[0]);
                        qsort(s, sz, sizeof(s[0]), cmp_s_age);
                        return 0;
                    }*/

                    /*//浮点数的qsort的写法
                    int cmp_float(const void* e1, const void* e2)
                    {
                        if (*(float*)e1 == *(float*)e2)//第一种写法
                            return 0;
                        else if (*(float*)e1 > *(float*)e2)
                            return 1;
                        else
                            return -1;

                        //return (int)(*(float*)e1 - *(float*)e2);//第二种写法
                    }

                    int main()
                    {
                        float farr[] = { 5.0,4.0,3.0,8.0,2.0,6.0,7.0,1.0 };
                        int sz = sizeof(farr) / sizeof(farr[0]);
                        qsort(farr, sz, sizeof(farr[0]), cmp_float);
                        int i = 0;
                        for (i = 0; i < sz; i++)
                        {
                            printf("%f ", farr[i]);
                        }
                        return 0;
                    }*/

                    /*//int类型排序 qsort 版
                    int cmp_int(const void* e1, const void* e2)
                    {
                        return *(int*)e1 - *(int*)e2;
                    }

                    int main()
                    {
                        int arr[] = { 9,7,8,6,5,4,3,2,1 };
                        int sz = sizeof(arr) / sizeof(arr[0]);
                        qsort(arr, sz, sizeof(arr[0]), cmp_int);//任意类型排序都可以排序
                        int i = 0;
                        for (i = 0; i < sz; i++)
                        {
                            printf("%d ", arr[i]);
                        }
                        return 0;
                    }*/


            qsort的内部是怎么样的 怎么做到什么样的类型都能够去排序 回调函数又是怎么用的
            
                代码：

                    void Swap(char* buf1,char*buf2,int width)
                    {
                        int i = 0;
                        for (i = 0; i < width; i++)
                        {
                            char tmp = 0;
                            tmp = *buf1;
                            *buf1 = *buf2;
                            *buf2 = tmp;
                            buf1++;
                            buf2++;
                        }
                    }

                    void bubble_sort(void* base, int sz, int width, int(*cmp)(const void*e1, const void*e2))
                    {
                        //趟数
                        int i = 0;
                        for (i = 0; i < sz; i++)
                        {
                            //每一趟比较的对数
                            int j = 0;
                            for (j = 0; j < sz - 1 - i; j++)
                            {
                                //两个元素的比较
                                if (cmp((char*)base + j * width, (char*)base) + (j + 1) * width > 0)
                                {
                                    //交换
                                    Swap((char*)base + j * width,(char*)base + (j + 1) * width,width);
                                }
                            }
                        }
                    }
                    
                    int cmp_int(const void* e1, const void* e2)
                    {
                        return *(int*)e1 - *(int*)e2;
                    }

                    void test1()
                    {
                        int arr[10] = { 9,8,7,6,5,4,3,2,1 };
                        int sz = sizeof(arr) / sizeof(arr[0]);
                        bubble_sort(arr, sz, sizeof(arr[0]),cmp_int);
                    }

                    int main()
                    {
                        test1();
                        return 0;
                    }





            指针和数组笔试题解析   都是必须要记住的！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
                //指针和数组笔试题解析
                //
                /*int main()
                {
                        
                    //地址的大小都是4/8个字节

                    //数组名是首元素的地址
                    //两个意外：
                    // 1.sizeof(数组名) - 数组名表示整个数组
                    // 2.&数组名 - 数组名表示整个数组
                    //一维数组
                    int a[] = { 1,2,3,4 };
                    printf("%d\n", sizeof(a));//sizeof(数组名)-计算的是数组总大小-单位是字节
                    printf("%d\n", sizeof(a+0));//4/8 - 数组名这里表示首元素的值，a+0 还是首元素的地址 地址的大小就是4/8个字节
                    printf("%d\n", sizeof(*a));//4 - 数组名表示首元素地址，*a就是首元素，sizeof(*a)就是4 ！！！
                    printf("%d\n", sizeof(a+1));//4/8 - 数组名这里表示首元素的值，a+1是第二个元素的地址 地址的大小就是4/8个字节 
                    printf("%d\n", sizeof(a[1]));//4 - 第2个元素的大小  ！！！
                    printf("%d\n", sizeof(&a));//4/8 &a取出的是数组的地址，但是数组的地址也是地址，地址的大小就是4/8字节
                    printf("%d\n", sizeof(*&a));//16 - &a数组的地址，数组的地址解引用访问的是数组，sizeof计算的就是数组的大小单位是字节
                    printf("%d\n", sizeof(&a+1));//4/8 - &a是数组的地址，&a+1虽然跳过整个数组，但还是数组，所以是4/8
                    printf("%d\n", sizeof(&a[0]));//4/8 - &a第一个元素的地址
                    printf("%d\n", sizeof(&a[0]+1));//4/8 - &a[0]+1 是第二个元素的地址
                    return 0;
                }/*/


                //字符数组
                int main()
                {
                    char arr[] = { 'a','b','c','d','e','f' };
                    //printf("%d\n", sizeof(arr));//6 - sizeof计算的是数组大小，6*1 = 6字节
                    //printf("%d\n", sizeof(arr + 0));//4/8 arr是首元素的地址，arr+0还是地址还是首元素的地址，地址的大小是4/8个字节
                    //printf("%d\n", sizeof(*arr));//1 - arr是首元素的地址，*arr就是首元素，首元素是字符大小是一个字节
                    //printf("%d\n", sizeof(arr[1]));//1 - arr[1]指的是第二个元素，元素当然是1个字节
                    //printf("%d\n", sizeof(&arr));//4/8 - &arr 虽然是数组的地址，但还是地址，地址大小是4/8个字节
                    //printf("%d\n", sizeof(&arr + 1));//4/8 - &arr+1 是跳过整个数组后的地址，那还是地址吗，地址大小是4/8个字节
                    //printf("%d\n", sizeof(&arr[0] + 1));//4/8 第二个元素的地址

                    //strlen 求字符串长度的
                    printf("%d\n", strlen(arr));//随机值 
                    printf("%d\n", strlen(arr + 0));//随机值
                    //printf("%d\n", strlen(*arr));//err 会使程序崩溃 因为传过去的是'a' = -97 然后向后数，非法访问了
                    //printf("%d\n", strlen(arr[1]));err err错误的意思 以后千万不能写出err的垃圾代码！！！！！！！！！！！！！！！
                    printf("%d\n", strlen(&arr));//随机值
                    printf("%d\n", strlen(&arr + 1));//随机值 - 6 跟上面的那个差值是6
                    printf("%d\n", strlen(&arr[0] + 1));//随机值 - 1 比上面的少个1 
                    return 0;
                }


                int main()
                {
                    //sizeof 计算所占空间的大小
                    char arr[] = "abcdef";
                    //printf("%d\n", sizeof(arr));//7 sizeof(arr)计算的数组的大小，单位是字节 7*1 = 7
                    //printf("%d\n", sizeof(arr + 0));//4/8 计算的是地址的大小 - arr + 0 是首元素的地址
                    //printf("%d\n", sizeof(*arr));//1 *arr是首元素，sizeof(*arr)计算首元素的大小
                    //printf("%d\n", sizeof(arr[1]));//1 arr[1]是第二个元素，sizeof(arr[1])计算的是第二个元素的大小
                    //printf("%d\n", sizeof(&arr));//4/8	&arr虽然是数组的地址，但也是地址，所以是4/8个字节
                    //printf("%d\n", sizeof(&arr + 1));//4/8	&arr+1是跳过整个数组后的地址，但而言是地址
                    //printf("%d\n", sizeof(&arr[0] + 1));//4/8 &arr[0] + 1 第二个元素的地址

                    //printf("%d\n", strlen(arr));//6	有6个元素
                    //printf("%d\n", strlen(arr + 0));//6	从首元素往后数
                    ////printf("%d\n", strlen(*arr));//err 非法访问 传的是'a'
                    ////printf("%d\n", strlen(arr[1]));//err 非法访问
                    //printf("%d\n", strlen(&arr));//6	从首元素往后数 数组的地址 - 数组指针 char (*p)[7] = &arr;   //5 6 7 都会报警告
                    //printf("%d\n", strlen(&arr + 1));//随机值
                    //printf("%d\n", strlen(&arr[0] + 1));//5 从第二个元素往后数
                    return 0;
                }



                /*int main()
                {
                    char* p = "abcdef";
                    //printf("%d\n", sizeof(p));//4/8 计算指针变量p的大小
                    //printf("%d\n", sizeof(p + 1));//4/8 p+1 得到的是字符b的地址
                    //printf("%d\n", sizeof(*p));//1 *p 就是字符串的第一个字符 - 'a'
                    //printf("%d\n", sizeof(p[0]));//1 int arr[10]; arr[0] == *(arr+0)         p[0] == (*p+0) == 'a'
                    //printf("%d\n", sizeof(&p));//4/8 地址
                    //printf("%d\n", sizeof(&p + 1));///4/8 地址
                    //printf("%d\n", sizeof(&p[0] + 1));//4/8 地址

                    printf("%d\n", strlen(p));//6
                    printf("%d\n", strlen(p + 1));//5
                    //printf("%d\n", strlen(*p));//err
                    //printf("%d\n", strlen(p[0]));//err
                    printf("%d\n", strlen(&p));//6
                    printf("%d\n", strlen(&p + 1));//随机值
                    printf("%d\n", strlen(&p[0] + 1));//5
                    return 0;
                }*/





                //二维数组
                int main()
                {
                    int a[3][4] = { 0 };
                    printf("%d\n", sizeof(a));//48 
                    printf("%d\n", sizeof(a[0][0]));//4
                    printf("%d\n", sizeof(a[0]));//16 a[0]相当于第一行作为一维数组的数组名，
                    //数组名叫sizeof(arr[0])把数组名单独放在sizeof()内，计算的是第一行的大小

                    printf("%d\n", sizeof(a[0] + 1));//4/8 a[0]是第一行的数组名，数组名此时是首元素地址，a[0]其实就是第一行第一个元素的地址
                    //所以 a[0] + 1 就是第一行第二个元素的地址，地址大小是4/8字节
                    printf("%d\n", sizeof(*(a[0]+1)));//4 *(a[0]+1)) 是第一行第二个元素，大小是4个字节
                    printf("%d\n", sizeof(a + 1));//4/8 a是二维数组的数组名，数组名没有sizeof(数组名)也没有	&(数组名)，所以a是首元素地址
                    //而二维数组看成一维数组时，二维数组的首元素是他的第一行，a就是第一行(首元素)的地址
                    //a+1就是第二行的地址
                    printf("%d\n", sizeof(*(a+1)));//16 sizeof(*(a+1)) 计算第二行的大小，单位是字节
                    printf("%d\n", sizeof(&a[0] + 1));//4/8	第二行的地址
                    printf("%d\n", sizeof(*(&a[0] + 1)));//16 计算第二行的大小，单位是字节
                    printf("%d\n", sizeof(*a));//16 a是首元素地址 - 第一行的地址，*a就是第一行，sizeof(*a) 就是计算第一行的大小
                    printf("%d\n", sizeof(a[3]));//4
                    return 0;
                }



            总结：
                数组名的意义
                    1.sizeof(数组名)，这里的数组名表示整个数组，计算的是整个数组的大小
                    2.&数组名，这里的数组名表示整个数组，取出的是数组的地址
                    3.除此之外所有的数组名都表示首元素的地址

                这些真的很重要，请一定要记住！！！

            指针笔试题

                笔试题 1：

                    int main()
                    {
                        //代码的执行结果是什么
                        int a[5] = { 1,2,3,4,5 };
                        int* ptr = (int*)(&a + 1);//取出的是数组，数组加1跳过整个数组
                        printf("%d,%d\n", *(a + 1), *(ptr - 1));//2 5
                        return 0;
                        //写代码有三种境界
                        // 1.看代码是代码
                        // 2.看代码是内存
                        // 3.看代码是代码 非常流畅

                        //线上笔试
                        //线下笔试 - 打印的卷子
                    }

                笔试题 2：

                    struct Test
                    {
                        int Num;
                        char* pcName;
                        short sDate;
                        char cha[2];
                        short sBa[4];
                    }*p;

                    //假设p 的值为0x100000。 如下面表达式的值分别为多少
                    //已知，结构体Test类型的变量大小是20个字节
                    int main()
                    {
                        p = (struct Test*)0x100000;//0x16进制的意思  0x1 就是1
                        printf("%p\n", p + 0x1);//0x100014    
                        printf("%p\n", (unsigned long)p + 0x1);//0x100008 转换成unsigned long 整型 整型加一 那就是一吗 
                        //把0x100000转换成10进制然后10进制去加一然后在转换成16进制
                        printf("%p\n", (unsigned int*)p + 0x1);//0x100004 //主要就是 *
                        return 0;

                        //这道题考的是 指针+ - 整数的
                        //				指针 + - 取决指针类型
                    }

                笔试题 3：

                    //笔试题3
                    int main()
                    {
                        int a[4] = { 1,2,3,4 };
                        int* ptr1 = (int*)(&a + 1);
                        int* ptr2 = (int*)((int)a + 1);
                        printf("%x,%x", ptr1[-1], *ptr2);//4 2000000 切换成32位就打印出来了
                        //%x”意思是16进制输出（以16进制输出变量地址）C语言中%x是用在标准输出和输入函数里的格式控制符。把整型值按16进制整型输出，不带前导0x
                        return 0;
                        //原来如此，ptr2移动的仅仅是一个字节位置，解引用后直接从第二个字节向后划定地址

                        //					        a
                        //   _______________________________________________
                        //  |      1           2           3           4    |
                        //  |01 00 00 00|02 00 00 00|03 00 00 00|04 00 00 00|
                        //  |_______________________________________________|
                        //  低地址									高地址

                        // 小端存储模式
                    } 

                笔试题 4：

                    //笔试题4
                    int main()
                    {
                                        //逗号表达式 是最后一个的结果
                        int a[3][2] = { (0,1),(2,3),(4,5) };
                                    //     1    3      5
                        int* p;
                        p = a[0];//p 里面放的是1
                        printf("%d", p[0]);// 1      *(p+0)
                        return 0;

                        //   a[0] | 1 3
                        //        | 5 0
                        //        | 0 0
                    }

                笔试题 5：

                //笔试题5
                int mian()
                {
                    int a[5][5];
                    int(*p)[4];
                    p = a;
                    printf("%p,%d\n", &p[4][2] - &a[4][2], &p[4][2] - &a[4][2]);//地址减地址得到的是什么呢 得到的是他们俩之间的元素个数
                    return 0;
                    //
                    //   a[0]              a[1]          a[2]            a[3]                a[4]
                    //[p+0][][][][p+1] [][][][p+2][] [][][p+3][][] [][p+4][][p+2][1] [2][3][4 a4 2][][]
                    //													地址减地址得到的是什么呢 得到的是他们俩之间的元素个数
                    //														所以是-4
                    //						p[4][2]= *(*(p+4)+2) 所以是上面的概念
                    //
                    //-4 在内存存储是  
                    //原码 10000000000000000000000000000100
                    //反码 11111111111111111111111111111011
                    //补码 11111111111111111111111111111100
                    //内存 1111 1111 1111 1111 1111 1111 1111 1100
                    //       F    F    F    F    F    F    F    C
                    //答：这组代码 最终答案是 0xFFFFFFFC，-4
                }

            笔试题 6：

                //笔试题6
                int main()
                {
                    int aa[2][5] = { 1,2,3,4,5,6,7,8,9,10 }; 
                    int* ptr1 = (int*)(&aa + 1);//&aa 代表的整个数组
                    int* ptr2 = (int*)(*(aa + 1));//*(aa + 1) = aa[1]第二行首元素的地址

                    printf("%d,%d\n", *(ptr1 - 1), *(ptr2 - 1));
                    return 0;

                    //		   aa					[ptr1 - 1]得到的是10
                    //   [1][2][3][4][5]   [6][7][8][9][10][&aa + 1]
                    // 补充：
                    //为什么*(aa + 1 )等价 aa[1] 呢
                    int arr[10] = { 1,2,3,4,5 };
                    int* p = arr;
                    //*(p+2) ==> p[2] ==> *(arr + 2) ==> arr[2]
                    arr[2];// ==>*(arr+2)
                }

            面试题 7：

                //阿里巴巴的面试题7
                int main()
                {
                    char* a[] = { "work","at","alibaba" };
                    char* * pa = a;

                    pa++;
                    printf("%s\n", *pa);
                    return 0;
                }

            面试题 8：

                //面试题8 相对复杂一点
                int main()
                {
                    char* c[] = { "ENTER","NEW","POINT","FIRST" };
                    char** cp[] = { c + 3,c + 2,c + 1,c };
                    char*** cpp = cp;
                    printf("%s\n", **++cpp);//第一个影响后面的 意思是 下一个算的时候不会重置
                    printf("%s\n", *-- * ++cpp + 3);
                    printf("%s\n", *cpp[-2] + 3);
                    printf("%s\n",cpp[-1][-1] + 1);
                    return 0;
                    // 结构图：
                    //		     c*			   cp*	==>	cpp**			结果
                    //		char*	E			c+3 = F						printf = POINT
                    //		char*	N			c+2 = P						printf = ER
                    //		char*	P			c+1 = N						printf = ST
                    //		char*	F			 c  = E						printf = EW

                    //补充：前置++，先++，后使用 意思是 先加上 在去打印
                    //		后置++，先使用，再++ 意思是 先打印 在加++
                    //注意：
                    // int a= 10;			*cpp[-2]+3				cpp[-1][-1]+1
                    // ++a;//a == 11		* *(cpp+(-2))+3			*(  *(cpp-1)-1  )+1
                    // ++a;//a == 12		* *(cpp-1)+3
                    // a-2 == 10
                }


