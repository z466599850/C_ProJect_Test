实用调试技巧
    · 什么是bug？
    · 调试是什么？有多重要？
    · debug和release的介绍。
    · windows环境调试介绍。
    · 一些调试的实力。
    · 如何写出好(易于调试)的代码。
    · 编程常见的错误。

        注：找bug的过程就叫调试 bug是计算机历史上的第一个bug  而那个bug就是臭虫
         第一次被发现的导致计算机错误的飞蛾，也是第一个计算机程序错误

    调试是什么?有多重要?
        所有发生的事情都一定有迹可循，如果问心无愧就不需要掩盖也就没有迹象了如果问心有
        愧，就必然需要掩盖，那就一定会有逆象，迹象越多就越容易顺藤而上，这就是推理的途
        径。顺着这条途径顺流而下就是犯罪，逆流而上 就是真相。

    一名优秀的程序员是一名出色的侦探。
       每一次调试都是尝试破案的过程。
    
    拒绝-迷信式调试!!!!
        调试(英语:Debugging/Debug)，又称除错，是发现和减少计算机程序或电子仪器设备中程
        序错误的一个过程。

    调试的基本步骤 很重要！！！！！！！！ 一定要好好检查BUG 做到一个BUG 也没有
        1.发现程序错误的存在
        2.以隔离、消除等方式对错误进行定位
        3.确定错误产生的原因
        4.提出纠正错误的解决办法
        5.对程序错误予以改正，重新测试

    Debug和Release的介绍
        Debug通常称为调试版本，它包含调试信息，并且不作任何优化，便于程序员调试程序

        Release称为发布版本，它往往是进行了各种优化，使得程序在代码大小和运行速度上都是最优
        的，以便用户很好地使用。代码:

    总结：Debug 就是测试版本  Release 就是正式版


    VS调试最常使用的几个快捷键:！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
        F5:启动调试，经常用来直接调到下一个断点处

        F9:创建断点和取消断点断点的重要作用，可以在程序的任意位置设置断点。这样就可以使得程席在
           想要的位置随意停止执行，继而一步步执行下去

        F10:逐过程，通常用来处理一个过程，一个过程可以是一次函数调用，或者是一条语句。

        F11:逐语句，就是每次都执行一条语句，但是这个快捷键可以使我们的执行逻辑进入函数内部(这是

        CTRL+F5:开始执行不调试，如果你想让程序直接运行起来而不调试就可以直接使用。

        Shift+F5：结束调试 不想调试了就直接结束
        
        写一组代码 去调试：
            int main()//计算n的阶乘   5！    5×4×3×2×1=120
            {
                int i = 0;
                int n = 0;
                int sum = 0;
                int ret = 0;
                scanf("%d", &n);
                for (i = 1; i <= n; i++)
                {
                    int j = 0;
                    ret = 1;
                    for (j = 1; j <= i;j++)
                    {
                        ret *= j;//ret = ret * j;
                    }
                    sum =  ret;//计算阶乘
                    //sum += ret; //计算阶乘相加//sum = sum + ret;
                }
                printf("sum = %d", sum);
                return 0;
            }

        这组代码为什么会造成死循环，研究死循环的原因
            int main()
            {
                int i = 0;
                int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
                for (i = 0; i <= 12; i++)
                {
                    printf("hehe\n");//nice 公司出过这道面试题
                    arr[i] = 0;//会造成死循环 因为在内存中分为栈区 堆区 静态区 然后在栈区是先使用高地址处的空间在使用低地址处的空间
                                //            i就一定在高地址创建 arr数组一定在i的下面创建随着数组下标的增长由低到高变化的，所以我
                            //             认为数组合适的往后越界在越界的过程中遇到i，然后在改变数组元素的时候，就有可能把i改变了   
                            //             就有可能会导致我们的程序死循环
                }    
                return 0;
            }

        如何写出好(易于调试)的代码
            优秀的代码:
                1.代码运行正常
                2.bug很少
                3.效率高
                4.可读性高
                5.可维护性高
                6.注释清晰
                7.文档齐全

            常见的coding技巧:
                1.使用assert //断言
                2.尽量使用const
                3.养成良好的编码风格
                4.添加必要的注释
                5.避免编码的陷阱。


            示范：
                模拟实现库函数：strcpy
                assert 和 const 和 strcpy 的用法： ！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
                    /*void my_strcpy(char* dest, char* src)
                    {
                        while (*src != '\0')//这组代码 在面试的时候只能给你 6分 那在改进一下吧
                        {
                            *dest = *src;
                            src++;
                            dest++;
                        }
                        *dest = *src;
                    }*/

                    /*void my_strcpy(char* dest, char* src)
                    {
                        while (*dest++ = *src++)// 7分 那在改进一下吧
                        {
                            ;
                        }
                    }*/


                    /*void my_strcpy(char* dest, char* src)
                    {
                        assert(dest != NULL);//断言     //找到错误并说明哪里错了
                        assert(src != NULL);//断言

                        while (*dest++ = *src++)// 8分 加上那两句话断言给8分那在改进一下吧
                        {
                            ;
                        }
                    }*/

                    /*int main()
                    {
                        int num = 10;
                        int n = 100;
                        int* p = &num;
                        //const 放在指针变量的*左边时，修饰的是*p，也就是说：不能通过p来改变*p(num) 的值 称常量指针
                        //const 放在指针变量的*右边是修饰的是指针变量p本身，P不能被改变了 // 称指针变量
                        //简单理解就是 const 放在哪里 谁就不能被改变
                        //也可以写成 const int* const p = &num;   这样*p 和p都改变不了
                        //如果写成 const int* p = &num;  p = &num; p = 20; 这个时候 就会改变num的值  但是*p改变不了 写成上面的两个都不会被改变

                        *p = 20;
                        p = &n;
                        p = 100;
                        printf("%d\n", num);
                        return 0;
                    }*/


                    void my_strcpy(char* dest, const char* src)//注意这里的const必须写在*的左边，表示数据只读，而不是指针只读 //谁的前面由const 就代表这个语句的值不能被改 
                                                                //const 是用来修饰指针的 const修饰谁，谁就改不了呗
                    {											
                        assert(dest != NULL);//断言
                        assert(src != NULL);//断言

                        while (*dest++ = *src++)// 10分 加上那两句话断言 在加上 const 给8分那在改进一下吧 const 解释在上面
                        {
                            ;
                        }
                    }
                    int main()
                    {
                        char arr1[] = "#################";
                        char arr2[] = "bit";
                        my_strcpy(arr1,arr2);//strcpy 是字符串拷贝
                        printf("%s\n", arr1);
                    } 


                    完整的strlen：
                    //补一下之前的strlen的分数 这样写可以达成满分 面试官一看哇塞小伙子不错哦！
                    int my_strlen(const char* str)
                    {
                        int count = 0;
                        assert(str != NULL);
                        while (*str != '\0')
                        {
                            count++;
                            str++;
                        }
                        return count;
                    }
                    int main()
                    {;
                        char arr[] = "abcdef";
                        int ret = my_strlen(arr);
                        printf("ret = %d\n", ret);
                        return 0;
                    }


            编程常见的错误

            常见的错误分类:
                编译型错误：
                    直接看错误提示信息(双击)，解决问题。或者凭借经验就可以搞定。相对来说简单

                链接型错误：
                    看错误提示信息，主要在代码中找到错误信息中的标识符，然后定位问题所在。一般是标识符名
                    不存在或者拼写错误。

                运行时错误：
                    借助调试，逐步定位问题。最难搞。

                温馨提示:
                    一定要做一个有心人，积累排错经验

                讲解重点:介绍每种错误怎么产生，出现之后如何解决

                本章完。


                