    深度剖析数据在内存中的存储
        本章重点
            1.数据类型详细介绍
            2.整形在内存中的存储:原码、反码、补码
            3.大小端字节序介绍及判断
            4.浮点型在内存中的存储解析
                数据在内存中到底是如何存储的

        数据类型介绍

        前面我们已经学习了基本的内置类型：
            C语言类型 分为两类：
                1.内置类型 
                char        //字符数据类型        1字节
                short       //短整型             2字节
                int         //整形               4字节
                long        //长整型             4字节
                long long   //更长的整形         8字节
                float       //单精度浮点数       4字节   指小数点后6位
                double      //双精度浮点数       8字节   指小数点后6位的位数更多

                2.自定义类型(构造类型) 自己可以创造类型 改变类型

                以及他们所占存储空间的按大小。类型的意义
                    1.使用这个类型开辟内存空间的大小(大小决定了使用范围)
                    2.如何看待内存空间的视角

            整形家族：
                char
                    unsigned char   无符号  范围是 0-255
                    signed char     有符号  范围是 -128-127
                short
                    unsigned short [int] 无符号 short int a = 10; short a = 10; 这两个写法是一样的
                    signed short [int]   有符号
                int
                    unsigned int    无符号
                    signed int      有符号
                long
                    unsigned long [int]   无符号    long int a = 10; long a = 10; 这两个写法是一样的
                    signed long [int]      有符号

            浮点型家族：
                folat   单精度浮点数
                double  双精度浮点数

            自定义类型又称(构造)类型：
                > 数组类型  int arr[10]; 数组名去掉就是类型 int [10]; int [5]; char [5];  这些就是数组类型
                > 结构体类型 struct 
                > 枚举类型 enum 
                > 联合类型 union 
            
            指针类型：
                int   *pi
                char  *pc
                float *pf
                void  *pv

            空类型：
                void 表示空类型(无类型)
                通常应用于函数的返回类型，函数的参数、指针类型

        整形在内存中的存储
            我们之前讲过一个变量的创建是要在内存中开辟空间的。空间的大小是根据不同的类型而决定的.
                那接下来我们谈谈数据在所开辟内存中到底是如何存储的?
            比如：
                int main()
                {
                    //在内存中存储是补码
                    int a = 20;//4个字节 32bit位         原反补都一样是因为 正数的原、反、补码都相同。   也称 无符号
                    //00000000000000000000000000010010 - 原码
                    //00000000000000000000000000010010 - 反码
                    //00000000000000000000000000010010 - 补码
                    //在内存中每四位相当于一个数  内存中是16进制      
                    //0x00000014 在内存中这样存储的
                    int b = -10;//						原反补不一样是因为	负数的原、反、补都不相同					
                    //10000000000000000000000000001010 - 原码
                    //11111111111111111111111111110101 - 反码
                    //1111 1111 1111 1111 1111 1111 1111 0110 - 补码
                    //在内存中每四位相当于1个数    内存中是16进制
                    //0xfffffff6 在内存中是这样存储的
                    return 0;
                }
            我们知道为a分配四个字节的空间。那如何存储?
                    //在内存中每四位相当于一个数  内存中是16进制      
                    int a = 20 //0x00000014     数据是这样显示的

                    //在内存中每四位相当于1个数    内存中是16进制
                    int b = -10 //0xfffffff6      数据是这样显示的

            下来了解下面的概念:
                原码、反码、补码
                    计算机中的有符号数有三种表示方法，即原码。反码和补码
                    三种表示方法均有符号位和数值位两部分，符号位都是用0表示“正”用1表示”负”，而数值位
                    三种表示方法各本相同
                原码：
                    直接特二进制按照正负数的形式翻译成二进制就可以。
                反码：
                    将原码的符号位不变，其他位依次按位取反就可以得到了
                补码：
                    反码+1就得到补码

        ---------------------------------------------------------分割线---------------------------------------------------------

        很重要哦这句话    正数的原、反、补码都相同。
                         负数的原、反、补码都不相同。

        ---------------------------------------------------------分割线---------------------------------------------------------
            对于整形来说:数据存放内存中其实存放的是补码

            为什么呢?
                在计算机系统中，数值一律用补码来表示和存储。原因在于，使用补码，可以将符号位和数值域统一处理，同
                时，加法和减法也可以统一处理(CPU只有加法器)此外补码与原码相互转换，其运算过程是相同的，不需
                要额外的硬件电路。
                
                int main()
                {
                    int a = 1 + (-1);//他是怎么算的呢
                    //得到1的补码 然后因为1是正数 所以原 反 补 都相同
                    // 1 的补码：00000000000000000000000000000001
                    // -1的补码：11111111111111111111111111111111
                    // 然后相加：100000000000000000000000000000000 然后 只能存储32位 所以直接省略左边的数
                    // 最终得到：00000000000000000000000000000000  是不是很神奇  想出来补码的人真的好厉害啊
                    // 最终得数是：0

                    // -1的原码：10000000000000000000000000000001
                    // -1的反码：11111111111111111111111111111110
                    // -1的补码：11111111111111111111111111111111
                    return 0;
                }

        补充：
            整数：
                1.有符号数 {
                                正数：原码、反码、补码 相同
                                负数：原码、反码、补码 不同，要继续你技术
                            }   
                2.无符号数  原码、反码、补码 相同

        注意：可是在内存中他是倒着存的
                a = 00000014
                b = 6fffffff 
                一看在内存中是这样存的顺序不对劲啊 这是为什么呢

                大小端介绍
                    什么大端小端:
                        大端(存储)模式，是指数据的低位保存在内存的高地址中，而数据的高位，保存在内存的低地址中

                        小端(存储)模式是指数据的低位保存在内存的低地址中，而数据的高位，保存在内存的高地址中

                        注：在VS当中用的是小端
                        例如： 0x11223344  44是低位 11是高位  然后放到内存中是 44 33 22 11  44是地位 11是高位
                              所以在内存中是倒着存储的  在VS中用的是小端存储模式  
                        
                        大端字节序存储模式  简称 大端模式
                        小端字节序存储模式  简称 小端模式

                    为什么有大端和小端:
                        为什么会有大小端模式之分呢?这是因为在计算机系统中，我们是以字节为单位的，每个地址单元都对应看一
                        个字节，一个字节为8bit。但是在C语言中除了8bit的char之外，还有16bit的short型，32bit的long型(要看具
                        体的编译器)，另外，对于位数大于8位的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字
                        节，那么必然存在看一个如果将多个字节安排的问题。因此就导致了大端存储模式和小端存储模式。

                        例如一个16bit的short型x 在内存中的地址为 0x0010，x的值为0x1122， 那么0x11为高字节，0x22为低字节。
                        对于大端模式，就将0x11放在低地址中 即0x0010 中，0x22 放在高地址中， 即0x0011中。小端模式，刚好相
                        反。我们常用的x86结构是小端模式，而KEIL C51则为大端模式。很多的ARM，DSP都为小端模式。有些ARM处理器
                        还可以由硬件来选择是大端模式还是小端模式

                    百度2015年系统工程师笔试题
                        请简述大端字节序和小端字节序的概念，设计一个小程序来判断当前机器的字节序，(10分)
                        int check_sys()
                        {
                            int a = 1;
                            return *(char*) & a;
                            //返回1，小端
                            //返回0，大端
                        }

                        int main()
                        {
                            //写一段代码告诉我们当前机器的字节序是什么
                            int ret = check_sys();
                            if (ret == 1)
                            {
                                printf("小端\n");
                            }
                            else
                            {
                                printf("大端\n");
                            }
                            return 0;
                        }

                        //指针类型的意义：
                        //1. 指针类型决定了指针解引用提作符能访问几个字节charp; p 访问了1个字节，intp;p 4个字节
                        //2. 指针类型决定了指+1，-1，加的或者减的是几个字节char *p; p+1,跳过一个字符，int*p，p+1,跳过一个整形 4个字节
                        int main()
                        {
                            int a = 0x11223344;
                            //int* p = &a;
                            //*p = 0;
                            char* p = &a;
                            *p = 0;
                            return 0;
                        }

                练习题：
                        //练习：下面会输出什么？
                        1.
                        int main()
                        {
                            char a = -1;//char 是1个字节
                                        //char 只能存放8个bit位所以只能存放8个数字 所以从后面取8个数字
                                        //然后 整型提升 意思是 一共有32个数 缺多少到32 补多少 
                                        //怎么补呢 当然是 有符号 高位补符号位，无符号，高位补0
                                        //前面两个ab是 111111111111111111111111这里开始补11111111
                                        //最后一个c是  000000000000000000000000这里开始补11111111
                                        //所以答案是 -1 -1 255
                            signed char b = -1;
                            unsigned char c = -1;//无符号按照补码来输出 这里会发生整型提升
                                                //有符号 高位补符号位，无符号，高位补0
                                                //为什么要整型提升呢 因为：char类型要用%d来打印 所以要整型提升
                            printf("a = %d,b = %d,c = %d", a, b, c);// -1 -1 255 
                            return 0;
                        }


                        2.
                        //-128
                        //100000
                        //10000000000000000000000010000000 - 原码
                        //11111111111111111111111101111111 - 反码
                        //11111111111111111111111110000000 - 补码
                        //整型提升
                        //11111111111111111111111110000000
                        //11111111111111111111111110000000 = 4294967168
                        //char 有符号数-128-127
                        //char 无符号数0-255
                        int main()
                        {
                            char a = -128;
                            printf("%u\n", a);//4294967168
                            return 0;
                        }


                        3.
                        int main()
                        {
                            char a = 128;// 超出范围了所以就是 char的有符号类型范围是-128-127 所以是127+1 = -128	他和第二题一样
                            printf("%u\n", a);
                            return 0;
                        }

                        4.
                        //a = 10000000000000000000000000010100 - 原码
                        //    11111111111111111111111111101011 - 反码
                        //    11111111111111111111111111101100 - 补码
                        //  
                        //b = 00000000000000000000000000001010 - 原码
                        //     
                        //	  

                        //a = 11111111111111111111111111101100
                        //					+ 
                        //b = 00000000000000000000000000001010
                        //a+b=11111111111111111111111111110110
                        //    11111111111111111111111111110101
                        //	  10000000000000000000000000001010 = -10
                        int main()
                        {
                            int a = -20;
                            unsigned int b = 10;
                            printf("%d\n", a + b);
                            return 0;
                        }
                            
                        //5.
                        int main()
                        {
                            unsigned int i;//因为他是无符号所以是0~255 他不可能被减成负数
                            for (i = 9; i >= 0; i--)
                            {
                                printf("%u\n", i);//所以这道题是死循环
                                Sleep(100);//Sleep 睡眠函数 睡眠100毫秒
                            }
                            return 0;
                        }

                        //6.
                        int main()
                        {
                            char a[1000];
                            int i;
                            for (i = 0; i < 1000; i++)
                            {
                                a[i] = -1 - i;

                            }
                            printf("%d", strlen(a));//答案：255 因为他算到了-128的时候不能继续算下去了 在鹏哥老师讲的那个圆圈中
                                                    //          他的范围是 -128-127 所以他算到-128他在算就变成了-129就变成了127 
                                                    //          然后算到127...5..4..3..2..1.....0  算到0的时候 OK   \0的ASCLL码
                                                    //          值对应的是0  所以算到0就结束了 所以他的结果是255个数 
                            return 0;
                        }



                        //7.
                        int main()
                        {
                            unsigned char i = 0;
                            for (i = 0; i <= 255; i++)
                            {
                                printf("hello world\n");//因为255+1变成了0  所以变成了死循环
                            }
                            return 0;
                        }

                总结：以后再用到无符号数的时候一定要注意哦 255+1变成了0  在使用的时候容易把程序弄成死循环


            浮点型在内存中的存储

                    常见的浮点数:
                        3.14159 1E10浮点数家族包括:float、double、long double类型。浮点数表示的范围:float.h中定义
                                1E10是科学计数法的意思是 1.0×10的10次方
                        整型范围在：limits.h   文件所在位置D:\VS Studio\Community\VC\Tools\MSVC\14.33.31629\include\limits.h
                        浮点数范围在：
                    浮点数存储的例子：
                        int main()
                        {
                            int n = 9;
                            float* pFloat = (float*)&n;
                            printf("%d\n", n);//9
                            printf("%f\n", *pFloat);//0.000000

                            *pFloat = 9.0;
                            printf("num的值为%d\n", n);//1091567616
                            printf("%f\n", *pFloat);//9.000000
                            return 0;
                        }
                        num和spFoat在内存中明明是同一个数，为什么浮点数和整数的解读结果会差别这么大?要理解这个结果，一定
                        要搞懂浮点数在计算机内部的表示方法

                        详细解读:

                        根据国际标准IEEE(电气和电子工程协会)754任意一个二进制浮点数V可以表示成下面的形式
                        
                        代码例子：

                        //9.0
                        //先把9.0改成2进制 左边9改成二进制.右边0也改成2进制 9的二进制是1001    0的二进制是0
                        //1001.0
                        //(-1)^S * M * 2^E
                        //(-1)^0 * 1.001 * 2^3  //(-1)^S S是判断9.0是正数还是负数 正数就是0 负数是1 
                        //								M是判断9.0科学计数法 1001 改成了 1.001 * 2^3次方 如果是1001.1 的话就是 1.0011 * 2^3
                        //								E是判断9.0转化为2进制小数点向左移动了3位所以M是3
                        //S = 0
                        //M = 1001
                        //E = 3

                        //0.5
                        //改成二进制
                        //0.1
                        //(-1)^0 * 1.0 * 2^-1
                        //S = 0
                        //M = 1.0
                        //E = -1	首先，E为一个无符号整数 如果E 为负数对于单精度浮点数范围是0-255 取他的中间数是127
                        //			对于11位的E，这个中间数是1023.比如，2^10的E是10，所以保存成32位浮点数时，必须保存
                        //			成10+127=137然后在把137改成二进制存到内存的E范围内  在内存中 范围分成 S E M !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 
                        //			所以 他是负数 那就 127 + E = 126
                        //		注意：无论E是负数还是正数都要加上8位或11位的中间数范围的值 8位中间数是127 11位中间数是1023!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 
                        int main()
                        {
                            int n = 9;
                            float* pFloat = (float*)&n;
                            printf("%d\n", n);//9
                            printf("%f\n", *pFloat);//0.000000

                            *pFloat = 9.0;
                            printf("%d\n", n);//1091567616
                            printf("%f\n", *pFloat);//9.000000
                            return 0;
                        }

            IEEE 754规定:对于32位的浮点数，最高的1位是符号位s 接着的8位是指数E，剩下的23位为有效数字M

                [][                  ][                                                             ]
                s(1bit)     E(8bit)                                 M(23bit)

                                                单精度浮点数存储模型

                对于64位的浮点数，最高的1位是符号位S，接着的11位是指数E，剩下的52位为有效数字M

                [][                      ][                                                                                 ]
                s(1bit)         E(11bit)                                                    M(52bit)
                                                双精度浮点数存储模型

                IEEE 754对有效数字M和指数E，还有一些特别规定。前面说过，1<=M<2，也就是说，M可以写成1.xxxxxx的形
                式，其中xxxxxx表示小数部分

                IEEE 754规定，在计算机内部保存M时，默认这个数的第一位总是1，因此可以被舍去，只保存后面的xxxxxx部分
                比如保存1.01的时候，只保存01，等到读取的时候，再把第一位的1加上去。这样做的目的，是节省1位有效数字.
                以32位浮点数为例，留给M只有23位，将第一位的1舍去以后，等于可以保存24位有效数字

                至于指数E，情况就比较复杂

                首先，E为一个无符号整数(unsigned int)这意味着，如果E为8位，它的取值范围为0-255;如果E为11位，它的
                取值范围为0-2047。但是，我们知道，科学计数法中的E是可以出现负数的，所以IEEE 754规定，存入内存时E
                的真实值必须再加上一个中间数，对于8位的E，这个中间数是127；对于11位的E，这个中间数是1023。比如2^10
                的E是10所以保存成32位浮点数时，必须保存成10+127=137即10001001
                注意：无论E是负数还是正数都要加上8位或11位的中间数范围的值 8位中间数是127 11位中间数是1023


                然后，指数E从内存中取出还可以再分成三种情况

                E不全为0或不全为1
                    这时。点数就采用下面的规则表示，即指数E的计算值减去127(或1023，得到真实值，再将有效数字M前
                    加上第一位的1。比如0.5(1/2)的二进制形式为01，由于规定正数部分必须为1将小数点右移1位
                    则为1.0*2AF1)，其阶码为-1+127=126，表示为01111110而尾数1.0去掉整数部分为0，补齐0到23位
                    00000000000000000000000，则其二进制表示形式为

                    001111110 00000000000000000000000

                E全为0
                    这时，浮点数的指数E等于1-127(或者1-1023)即为真实值，有效数字M不再加上第一位的1，而是还原为
                    0.xxxxxx的小数。这样做是为了表示+0，以及接近于0的很小的数字

                E全为1
                这时，如果有效数学M全为0，表示正负无穷大(正负取决于符号位s)

                代码例子：
                int main()
                {

                    float f = 5.5;
                    //5.5
                    //101.1 右边的数是怎么来的呢 就是把右边的5看成0.5然后0.5乘2 取整数 直到取的是0的时候就算停了
                    //							意思是 乘二取整 正向排列
                    //(-1)^0 * 1.011 * 2^2
                    //s = 0
                    //m = 1.011
                    //e = 2
                    //在内存中存储 的顺序是 S E M 
                    // 0 10000001 01100000000000000000000
                    //存储S的时候0是最高位  存储E的时候 10000001 是8位比特位的中间数127+E= 129 然后在改成2进制 得到的数  011是 1.001	
                    //存储M的时候 小数点左边一般不写直接存储后面的数 取出来的时候自动补上  因为存储了3个数 不够23位所以 位置不满的时候要自动补0
                    //注意：位置不满的时候要自动补0
                    //在内存中存储是0100 0000 1011 0000 0000 0000 0000 0000每4位一组 因为是16进制 8 4 2 1
                    //0x40B00000 小端 所以在内存存储的是 00 00 b0 40

                    //从内存中取出来
                    //0 10000001 01100000000000000000000
                    //10000001  129 - 127 = 2 129是E 的存储值 2是E 的真实值
                    //0 10000001 01100000000000000000000
                    //+/-0.011 * 2^-126
                    //
                    //0 111111111 01100000000000000000000
                    //E+127 = 255
                    //E = 128
                    //1.xxx * 2……128
                    //表示正负无穷大
                    return 0;
                }


                然后我们回到那个题仔细看一下：

                int main()
                {
                    int n = 9;
                    //0 00000000 00000000000000000001001 - 补码
                    //S E                 M 
                    float* pFloat = (float*)&n;
                    printf("%d\n", n);//9
                    printf("%f\n", *pFloat);//0.000000
                    //0.00000000000000000001001 E为全0的时候M取出来的时候 小数点前面的1就不要了 E 就算直接1-127
                    //							那就是(-1)0 * 0.00000000000000000001001 * 2^-126
                    //然后%f指打印小数点后面6位的话 那就是 0.000000 后面的不要哦！ 00000000000001001
                    *pFloat = 9.0;
                    //1001.0
                    //1.001 * 2^3
                    //(-1)^0 * 1.001 * 2^3
                    //0 10000010 00100000000000000000000 然后一看是按%d整数取出来 所以就是 原反补相同 然后把这个数转换成10进制
                    //所以是 1091567616

                    //第二个是因为以9.0的形式放进去 以9.0的形式取出来 所以是9.0  上面的是因为 以整数9 放进去 以浮点数取出来 所以不一样 
                    //总结：整数和浮点数存储的方式不一样 放进去的方式和取出来的方式不一样 所以以后要整数放进去的要从整数取 浮点数放进去的要用浮点数取
                    //分析：浮点数就应该按照浮点数的方式存 取 ，整数就应该以整数的方式存取
                    printf("%d\n", n);//1091567616
                    printf("%f\n", *pFloat);//9.000000
                    return 0;
                }


                总结：整数和浮点数存储的方式不一样 放进去的方式和取出来的方式不一样 所以以后要整数放进去的要从整数取 浮点数放进去的要用浮点数取
                分析：浮点数就应该按照浮点数的方式存 取 ，整数就应该以整数的方式存 取
            好了，关于浮点数的表示规则，就说到这里

            