自定义类型:结构体，枚举，联合

    char
    int
    short
    long
    float
    double
    内置类型 - C语言自己的数据类型
    ----------------
    
    复杂对象
    复杂类型 
    自定义类型：结构体、枚举、联合体  
    人
    书

    本章重点
        · 结构体
            结构体类型的声明
            结构的自引用
            结构体变量的定义和初始化
            结构体内存对齐
            结构体传参
            结构体实现位段(位段的填充&可移植性)

        · 枚举
            枚举类型的定义
            枚举的优点
            枚举的使用

        · 联合
            联合类型的定义
            联合的特点
            联合大小的计算


        正文开始
            结构体

            结构体类型的声明

            结构的基础知识
                结构是一些值的集合，这些值称为成员变量。结构的每个成员可以是不同类型的变量。

            结构的声明

                //声明一个结构体类型
                //声明一个学生类型，是想通过学生类型来创建学生变量(对象)
                //描述学生：属性 - 名字 - 电话- 性别 - 年龄
                struct Stu // 结构体声明 结构体名字
                {
                    char name[20];//名字
                    char tele[12];//电话
                    char sex[10];
                    int age;
                    //大括号里的是成员变量
                }s4,s5,s6;//全局变量

                struct Stu s3;//全局变量 分号不能丢

                int main()
                {
                    //创建的结构体变量
                    struct Stu s1;
                    struct Stu s2;
                    return 0;
                }


            特殊的声明

                在声明结构的时候，可以不完全的声明。

                比如 :

                    struct
                    {
                        int a;
                        char c;

                    }sa;//用一次就不能再用了 在用一次结构体的时候可以用到匿名结构体声明

                    struct
                    {
                        int a;
                        char c;

                    }*psa;
                    int main()
                    {
                        psa = &sa;
                        return 0;
                    }


                上面的两个结构在声明的时候省略掉了结构体标签(tag)

                那么问题来了 ?

                    //在上面代码的基础上，下面的代码合法吗?

                    psa = &sa;

                警告:编译器会把上面的两个声明当成完全不同的两个类型。 所以是非法的。


            结构的自引用
                在结构中包含一个类型为该结构本身的成员是否可以呢 ?

            自引用方式：

                //数据结构：数据在内存中存储的结构
                //链表
                //随意存放1 2 3 4 5 但是他们像一个链子连着起来
                struct Node
                {
                    int data;
                    struct Node n;//节点存放的不是数字，而是存放下一个节点的地址 err的
                    struct Node* next;
                };

                int main()
                {
                    sizeof(struct Node);
                    return 0;
                }


            注意：

                typedef struct Node //如果去掉Node 那下面的就不能用了自引用的话不建议省略掉Node 注：结构体要想找到同类型结构体的话要用指针
                {
                    int data;
                    struct Node n;//节点存放的不是数字，而是存放下一个节点的地址 err
                    struct Node* next;//correct
                }Node;//类型名

                int main()
                {
                    struct Node n1;
                    Node n2;//只要加了typedef对结构体重命名 然后在分号前面输入名字 就可以用了 这两种写法都可以
                    return 0;
                }





            结构体变量的定义和初始化

                有了结构体类型，那如何定义变量，其实很简单

                    struct T
                    {
                        double weight;
                        short age;
                    };

                    struct S
                    {
                        char c;
                        struct T st;//结构体嵌套
                        int a;
                        double d;
                        char arr[20];
                    };


                    int main()
                    {
                        struct S s = { 'c',{55.4,17},100,3.14,"hello bit" };//结构体初始化 + 结构体嵌套初始化
                        printf("%c %lf %d %d %lf %s\n", s.c, s.st.weight, s.st.age, s.a, s.d, s.arr);//结构体打印
                        return 0;
                    }





            结构体内存对齐

                我们已经掌握了结构体的基本使用了

                现在我们深入讨论一个问题:计算结构体的大小。

                这也是一个特别热门的考点:结构体内存对齐
                
                练习1：

                    struct S1
                    {
                        char c1;
                        int a;
                        char c2;
                    };

                    struct S2
                    {
                        char c1;
                        char s2;
                        int a;
                    };
                    struct S3
                    {
                        double d;
                        char c;
                        int i;
                    };
                    struct S4
                    {
                        char c;
                        struct S3 s3;
                        double d;
                    };
                    int main()
                    {
                        struct S1 s1 = { 0 };
                        printf("s1 = %d\n", sizeof(s1));
                        struct S2 s2 = { 0 };
                        printf("s2 = %d\n", sizeof(s2));
                        struct S3 s3 = { 0 };
                        printf("s3 = %d\n", sizeof(s3));
                        struct S4 s4 = { 0 };
                        printf("s4 = %d\n", sizeof(s4));
                        return 0;
                    }


                    sizeof算的是多少？

                    考点如何计算?首先得掌握结构体的对齐规则:
                        1.第一个成员在与结构体变量偏移量为0的地址处。
                        2.其他成员变量要对齐到某个数字(对齐数)的整数倍的地址处
                        对齐数 = 编译器默认的一个对齐数与 该成员大小的较小值
                            注：vS中默认的值为8
                                gcc没有默认对齐数 成员的大小就是他的对齐数
                        3.结构体总大小为最大对齐数(每个成员变量都有一个对齐数)的整数倍
                        4.如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整
                        体大小就是所有最大对齐数(含嵌套结构体的对齐数)





                    //假如我们要算 s1
                    //假如行是我们的内存
                    //这是s1的位置 c1 假如也在这里 .第一个成员在与结构体变量偏移量为0的地址处  也就是c1 要在0的位置 从0的位置开始算 0 也是 1个字节哦 
                    // 
                    //
                    //
                    // 1 a的位置从这开辟4个字节 a的字节和对齐数比较一下 然后放在 整数倍上 假如int 的字节是4 在内存中要放在 4的倍数上面
                    // 2
                    // 3
                    // 4
                    // 1 c2 的位置 VS默认对齐数是8 
                    //  然后一看是9个字节 然后这个成员变量里的最大的字节也要和9字节对齐一看最大的字节是4 那9是不是4的倍数吗 不是所以就往后补
                    //
                    // 12 是4的倍数 OK 结果是12 没有放值的空间就浪费了


0 s3 1  1
1   2   2
2   3   3
3   4   4
4   5   5
5   6   6
6   7   7
7   8   8
8   1   9
9       10
10      11
11      12
12  1   13
13  1   14
14  1   15
15  1   16


1
2
3
4
5
6
7
7 8
8 1
9
10
11
12 1
2
3
4

0 c
1
2
3
41
52
63
74
85
96
10 7
11 8
12 1
13 2
14 3
15 4
16
17
18
19
20
21
22
23
24


        为什么存在内存对齐?

            大部分的参考资料都是如是说的：

                 1.平台原因(移植原因):不是所有的硬件平台都能访问任意地址上的任意数据的，某些硬件平台只能
                   在某些地址处取某些特定类型的数据，否则抛出硬件异常

                 2.性能原因:数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的
                   内存，处理器需要作两次内存访问，而对齐的内存访问仅需要一次访问。

            总体来说：
                结构体的内存对齐是拿空间来换取时间的做法。






            那在设计结构体的时候，我们既要满足对齐，又要节省空间，如何做到 :

                答：让占用空间小的成员尽量集中在一起、

                例如：

                    struct S1
                    {
                        char c1;
                        int i;
                        char c2;
                    };

                    struct S2
                    {
                        char c1;
                        char c2;
                        int i;
                    }

                 S1 占12个 S2占8个 
                 S1和S2类型的成员一模一样，但是S1和S2所占空间的大小有了一些区别。



            修改默认对齐数

                之前我们见过了 #pragma 这个预处理指令，这里我们再次使用，可以改变我们的默认对齐数

                    //一般情况下都设置2的次方数例如：2 4 8 16 这样的数字 不建议设置奇数
                    //#pragma pack(4)//设置默认对齐数为4 结果是 12 
                    //struct S
                    //{
                    //	char c1;
                    //	double d;
                    //};
                    //#pragma pack()//取消设置的默认对齐数

                    #pragma pack(1)//设置默认对齐数为1 结果是9
                    struct S
                    {
                        char c1;
                        double d;
                    };
                    #pragma pack()//取消设置的默认对齐数


                    int main()
                    {
                        struct S s = { 0 };
                        printf("%d\n", sizeof(s));
                        return 0;
                    }


            结论:
                结构在对齐方式不合适的时候，我么可以自己更改默认对齐数。
                注：一般情况下都设置2的次方数例如：2 4 8 16 这样的数字 不建议设置奇数


            百度笔试题:
                写一个宏，计算结构体中某变量相对于首地址的偏移，并给出说明

            考察:offsetof宏的实现
                注:这里还没学习宏，可以放在宏讲解完后再实现

            代码：
                struct S
                {
                    char c;
                    int i;
                    double d;

                };

                int main()
                {
                    //offsetof();//offset 偏移量 of谁的偏移量//用来计算结构体成员相对于结构体起始位置的偏移量是几
                                //它不是一个函数，是一个宏！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
                                //用法：size_t offsetof(结构体名，结构体成员变量的名字) 返回的是偏移量
                    printf("%d\n", offsetof(struct S, c));//注：传的是结构体类型名，不是结构体变量名
                    printf("%d\n", offsetof(struct S, i));//要引用头文件 #include <stddef.h>
                    printf("%d\n", offsetof(struct S, d));
                    //偏移量是 0 4 8
                    //它不是一个函数，是一个宏！
                    //offsetof 可以求出偏移量的
                    return 0;
                }







        结构体传参
            直接上代码:

                struct S
                {
                    int a;
                    char c;
                    double d;
                };

                void Init(struct S* ps)
                {
                    ps->a = 100;
                    ps->c = 'w';
                    ps->d = 3.14;
                }

                void Print1(struct S tmp)//传值
                {
                    printf("%d %c %lf\n", tmp.a, tmp.c, tmp.d);
                }

                void Print2(struct S* ps)//传址 这种传法更好一些 如果怕被改变可以加const
                {
                    printf("%d %c %lf\n", ps->a, ps->c, ps->d);
                }
                int main()
                {
                    struct S s = { 0 };

                    //传参
                    //Init(s);//err
                    Init(&s);
                    Print1(s);//不好 这种方法不好 如果传的字节过大，会导致性能下降
                    Print2(&s);//这种方法好点 因为传的地址不管三七二十一都是4/8

                    //在主函数里实现
                    //s.a = 100;
                    //s.c = 'w';
                    //s.d = 3.14;
                    //printf("%d\n", s.a);
                    return 0;
                }


            上面的print1和print2函数哪个好些?

                答案是:首选print2函数。原因:
                    函数传参的时候，参数是需要压栈，会有时间和空间上的系统开销。

                    如果传递一个结构体对象的时候，结构体过大，参数压栈的的系统开销比较大，所以会导致性能
                    的下降。

                结论:结构体传参的时候，要传结构体的地址。







        位段

            结构体讲完就得讲讲结构体实现（位段）的能力

            什么是位段

            位段的声明和结构是类似的，有两个不同
                1.位段的成员必须是int、unsigned int 或signed int。char short 不会有float double类型出现
                2.位段的成员名后边有一个冒号和一个数字。
            注意：位段里面只能出现一种类型 不能同时出现两种不一样的类型

            比如：

                //位段 - 二进制位
                struct S
                {
                    int a : 2;//abcd后面的：数字 指的是你要占几个比特位
                    int b : 5;
                    int c : 10;
                    int d : 30;
                    // 2 + 5 + 10 + 30 = 47个比特位 
                };

                int main()
                {
                    struct S s;
                    printf("%d\n", sizeof(s));
                    return 0;
                }

                S就是一个位段类型。

                那位段A的大小是多少 ?

                printf("%d\n", sizeof(s));

                //位段 - 二进制位
                //位段是为了节省空间用的
                struct S
                {
                    int a : 2;//abcd后面的：数字 指的是你要占几个比特位
                    int b : 5;
                    int c : 10;
                    int d : 30;//位段后面的数字不能大于32
                    // 2 + 5 + 10 + 30 = 47个比特位 
                    //怎么开辟的呢
                    //先开辟4个字节的空间 32个比特位 然后 32 - 2 -5 -10=15 然后后面是30发现不够了 
                    //那么上一个开辟的空间剩下的15个字节 不要了 直接去开辟一个新的空间 32 -30 = 2  然后这2字节也不要了 因为已经开辟完了 所以结果是8个字节
                };

                int main()
                {
                    struct S s;
                    printf("%d\n", sizeof(s));//8
                    return 0;
                }


            位段的内存分配
                1.位段的成员可以是int unsigned int signed int 或者是char (属于整形家族)类型
                2.位段的空间上是按照需要以4个字节( int )或者1个字节( char )的方式来开辟的。
                3.位段涉及很多不确定因素，位段是不跨平台的，注重可移植的程序应该避免使用位段

                例子：

                struct S
                {
                    char a : 3;
                    char b : 4;
                    char c : 5;
                    char d : 4;
                    //它是怎么开辟空间的呢 char类型一次只开辟一个字节 一个字节等于8个比特位
                    //00000000
                    // 放 8-a-b= 1 所以能放下 然后剩下一个 一个不要了
                    //00000000
                    //开辟一块新的空间 放c  8-5=3 放得下 剩下3个不够放d了
                    //00000000
                    // 在开辟一块新的空间 放d 8-4=4 剩下4个空间 不要了
                    //然后把主函数里的值转换成二进制放到内存里
                    // a = 10 = 1010
                    // b = 20 = 10100
                    // c = 3  = 11
                    // d = 4  = 100
                    //然后开始放
                    //0b0100a010 a b的位置 a只能放3个 所以只能从右向左取3个 所以a 010 b也只能取4个 b 0100
                    //000c00011   c的位置 c可以全放 00011 然后自动补齐到够5个
                    //0000d0100    d的位置 d可以全放 0100 然后自动补齐到4个
                    //然后在内存里是16进制 每四位为一组
                    //0010 0010 0000 0011 0000 0100
                    // 2     2   0    3     0    4
                    //220304 在内存种是220304 nice居然对了！！！！ every good
                };

                int main()
                {
                    struct S s = { 0 };
                    s.a = 10;
                    s.b = 20;
                    s.c = 3;
                    s.d = 4;
                    return 0;
                }




            位段的跨平台问题
                1.int位段被当成有符号数还是无符号数是不确定的
                2.位段中最大位的数目不能确定。(16位机器最大16，32位机器最大32，写成27，在16位机
                器会出问题。
                3.位段中的成员在内存中从左向右分配，还是从右向左分配标准尚未定义。
                4、当一个结构包含两个位段，第二个位段成员比较大，无法容纳于第一个位段剩余的位时，是
                舍弃剩余的位还是利用，这是不确定的。

            总结:
                跟结构相比，位段可以达到同样的效果，但是可以很好的节省空间，但是有跨平台的问题存在.

            位段的应用

                0                                       15 16                              31
                ______________________________________________________________________________
                |4位版本号 4位首部长度  | 8位服务类型（TOS）| 16位总长度(total length)      |   
                ——————————————————————————————————————————————————————————————————————————  
                |             16位识符(identifier)         | 3位标志|13 位片偏移(offset )  |
                ———————————————————————————————————————————————————————————————————————————
                |        8位生存时间TTL   | 8位协议          |       16位首部校验和         |  
                |        (time to live)  | (protocol)       |        (checksum)           |  20字节
                ———————————————————————————————————————————————————————————————————————————
                |                       2 位源IP地址(source address)                       |
                ————————————————————————————————————————————————————————————————————————————
                |                   32 位目的IP地址(destinatin address)                    |
                ————————————————————————————————————————————————————————————————————————————————
                |                           32 位选项(若有)                                |
                ————————————————————————————————————————————————————————————————————————————
                |                               数据                                       |
                ————————————————————————————————————————————————————————————————————————————







        枚举

            枚举顾名思义就是一一列举。

            把可能的取值一一列举。

            比如我们现实生活中:

               一周的星期一到星期日是有限的7天，可以一一列举。

               性别有 : 男、女、保密，也可以一一列举。

               月份有12个月，也可以一一列举

            这里就可以使用枚举了


            枚举类型的定义：

                enum Day//星期  enum 枚举的类型
                {
                    Mon,
                    Tues,     枚举的可能取值
                    Wed,
                    Thur,
                    Fri,
                    Sat,
                    Sun
                };




                例2：

                //enum Sex//枚举类型
                //{
                //	//枚举的可能取值-常量
                //	MALE = 2,//这不是改 这是给他一个值 他是一个常量他得有一个值吧 就跟 const int num = 100;//一样
                //	FEMALE = 4,
                //	SECRET = 8
                //};

                //enum Color
                //{
                //	RED,//0
                //	GREEN,//1
                //	BLUE//2
                //};

                //我们也可以这样定义，但是不如枚举enum
                //c语言的源代码---预编译----编译-----链接------>可执行程序
                #define RED 0
                #define GREEN 1
                #define BLUE 2

                int main()
                {
                    //enum Sex s=MALE;
                    //s = FEMALE; //其他的值不能放 规定了可能取值就只能放可能取值

                    //enum Color c = 2;//int err 虽然没报错是因为编译器不够严格 如果改成后缀名cpp cpp c++的意思 他就会报错 c++更严格一点
                    //enum Color c = BLUE;

                    int color = RED;//我们也可以通过#define定义，但是不如枚举enum

                    //printf("%d %d %d\n", RED, GREEN, BLUE);//从第一个默认往下依次递增
                    //printf("%d %d %d\n", MALE,FEMALE,SECRET);//从第一个默认往下依次递增
                    return 0;
                }





            枚举的优点

                为什么使用枚举?
                
            我们可以使用#define 定义常量，为什么非要使用枚举？枚举的优点：

                1.增加代码的可读性和可维护性
                2.和#define定义的标识符比较枚举有类型检查，更加严谨
                3.防止了命名污染(封装)
                4.便于调试
                5.使用方便，一次可以定义多个常量

            枚举的使用

                enum Color //颜色
                {
                    RED = 1;
                    GREEN = 2;
                    BLUE = 4
                };

                enum Color clr = GREEN;//只能拿枚举常量给枚举变量赋值，才不会出现类型的差异。
                clr = 5;                //OK? 不ok










            联合(共用体 )

            联合类型的定义

            联合也是一种特殊的自定义类型 这种类型定义的变量也包含一系列的成员，特征是这些成员公用同一块
            空间(所以联合也叫共用体)。比如 :

            //联合-联合体-共用体
            union Un//联合体的类型 union
            {
                char c;
                int i;
            };

            int main()
            {
                union Un u;
                printf("%d\n", sizeof(u));//猜猜几个字节 答：4个字节 因为他们共用一个地址

                printf("%p\n", &(u));

                printf("%p\n", &(u.c));
                printf("%p\n", &(u.i));

                return 0;
            }


            联合的特点
                联合的成员是共用同一块内存空间的，这样一个联合变量的大小，至少是最大成员的大小(因为
                联合至少得有能力保存最大的那个成员)

                union Un
                {
                    int i;
                    char c; //我要是改c了 i也跟着改了 只能用一个
                }；
                union Un un;

                //下面输出的结果是一样的吗？
                printf("%d\n",&(un.i));
                printf("%d\n",&(un.c));


                //下面输出的结果是什么？
                un.i = 0x11223344;
                un.c = 0x55;
                printf("%x\n",un.i);



        面试题:

            判断当前计算机的大小端存储

            答案：

            //第一种写法
            //int check_sys()
            //{
            //	int a = 1;
            // //返回1，表示校端
            // //返回0，表示大端
            //	return *(char*)&a;
            //}

            //第二种写法
            int check_sys()
            {
                union //匿名结构体 用一次就不用了
                {
                    char c;
                    int i;
                }u;
                u.i = 1;
                //返回1，表示校端
                //返回0，表示大端
                return u.c;
            }
            int main()
            {
                int a = 1;
                int ret = check_sys();

                if (ret == 1)
                {
                    printf("小端\n");
                }
                else
                {
                    printf("大端\n");
                }
                //int a = 0x11223344;
                //低地址------------------>高地址
                //....[][][][][11][22][33][44][][][][][][][]][][][]...  大端字节序存储模式
                //....[][][][][44][33][22][11][][][][][][][]][][][]...  小端字节序存储模式
                //讨论一个数据，放在内存中的存放的字节顺序
                //大小端字节问题
                //

                return 0;
            }

        联合大小的计算

            联合的大小至少是最大成员的大小。
            当最大成员大小不是最大对齐数的整数倍的时候，就要对齐到最大对齐数的整数倍.

        比如：


            union Un
            {
                int a;//4 8 4 
                char arr[5];//5 1 8 1 写的是arr[5] 但还是拿char类型来算 就跟写了5个cahr一样
                            // 然后5是不是4的倍数 不是 所以加3 他们的字节是 8个字节
                            //当算数组的时候算的是他元素的对齐数不是总共有几个元素
                //总结：
                //结构体存在对齐
                //位段为了节省空间不存在对齐
                //枚举也不存在对齐 枚举的大小都是4个字节
                //联合体是存在对齐的
            };

            int main()
            {
                union Un u;
                printf("%d\n", sizeof(u));//8个字节
                return 0;
            }




        练习：

        通讯录程序
