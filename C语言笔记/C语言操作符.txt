操作符详解

操作符和表达式

本章重点
1.各种操作符的介绍
2.表达式求值


操作符
分类：
    算术操作符
    移位操作符
    位操作符
    赋值操作符
    单目操作符
    关系操作符
    逻辑操作符
    条件操作符
    逗号表达式
    下标引用、函数调用和结构成员

算术操作符
  分类： + - * / %
  1.除了%操作符之外，其他的几个操作符可以作用于整数和浮点数
  2.对于/操作符如果两个操作数都为整数，执行整数除法。而只要有浮点数执行的就是浮点数除
  3%操作符的两个操作数必须为整数。返回的是整除之后的余数

  代码：
int main()
{
	int a = 5 / 2;//商2余1   2
	int b = 5 % 2;//余1      1
	double c = 5 / 2.0;//浮点数
	//double d = 5 % 2.0;//这里不行的 取模两个操作数必须为整数，返回的是整除之后的余数
	printf("a = %d\nb = %d\nc = %lf\n", a,b,c);
	return 0;
}

移位操作符
  分类：<<左移操作符
        >>右移操作符
    左移操作符移位规则：左边抛弃、右边补0

    代码：
int main()
{
	int a = 16;
	a >> 1;
	//>> 右移操作符
	//移动的是二进制位 
	//0000000000000000000000000000000010000 
	//a空间 向右移动一位
	//1.算术右移
	//  右边丢弃，左边补原符号位 （0 正数 1 负数）
	// 
	//2.逻辑右移
	//  右边丢弃，左边补0
	int b = a >> 1;
	printf("a = %d", b);
	return 0;
}
    重点：
    int a = 16;
    >> 右移操作符
	移动的是二进制位 
	0000000000000000000000000000000010000 
	a的空间 向右移动一位
	1.算术右移
	  右边丢弃，左边补原符号位 （0 正数 1 负数）首个数字就是原符号位
	  通常情况下都是算术右移
	2.逻辑右移
	  右边丢弃，左边补0

int main()
{
	int a = -1;
	// 100000000000000000000000000000001
	//整数的二进制有，源码，反码，补码
	//存储到内存钟的是 补码 重点！！！！！！！！！
	// 100000000000000000000000000000001 - 源码
	// 111111111111111111111111111111110 - 反码 符号位不变 其他位按位取反
	// 111111111111111111111111111111111 - 补码 反码加一 得到反码
	//算术右移 补码向右移一位 右边丢弃一个 左边补原符号位 所以还是原来的数就是 -1
	int b = a >> 1;
	printf("a = %d", b);// -1
	return 0;
}

超级重点：右移操作符包括：算术右移和逻辑右移

左移操作符：

int main()
{
	int a = 5;
	int b = a << 1;
	//00000000000000000000000000000000101
	//左移操作符：左边丢弃，右边补0	 向左移动有×2的效果
	printf("%d", b);
	return 0;
}

无敌总结:右移操作符 
            1. 算术右移 
	        右边丢弃，左边补原符号位 （0 正数 1 负数）首个数字就是原符号位
	        通常情况下都是算术右移
	        2.逻辑右移
	        右边丢弃，左边补0
        左移操作符：左边丢弃，右边补0	 向左移动有×2的效果

    规律：
            右移操作符有除2的效果
            左移操作符有乘2的效果

    警告A:对于移位运算符，不要移动负数位，这个是标准未定义的。 例如

        int num = 10;
        num >>-1;


位操作符：
   分类：
        & //按位与
        | //按位或
        ^ //按位异或
      注：他们的操作数必须是整数

代码：

int main()
{
	//& 按2进制与
	int a = 3;
	int b = 5;
	int c = a & b;//只有两个相等的1才是 1
	//00000000000000000000000000000000011
	//00000000000000000000000000000000101
	// 按位与：
	//00000000000000000000000000000000001
	printf("%d\n", c);

	// | - 按2进制或
	int a = 3;
	int b = 5;
	int c = a | b;//只要有一个1 那就是 1
	printf("%d\n", c);
	//00000000000000000000000000000000011
	//00000000000000000000000000000000101
	//00000000000000000000000000000000111

	//按2进制位异或
	int a = 3;
	int b = 5;
	int c = a ^ b;//相同为0，相异为1 相同的都是0
	printf("%d\n", c);
	//00000000000000000000000000000000011
	//00000000000000000000000000000000101
	//00000000000000000000000000000000110
	return 0;
}


    一道变态的面试题:
            不能创建临时变量(第三个变量)，实现两个数的交换

代码：
int main()
{
	int a = 3;
	int b = 5;
	int sum = 0;//临时变量
	printf("before：a=%d b=%d\n",a,b);
	/*sum = a;
	a = b;
	b = sum;*/

	//加减法-可能会溢出
	/*a = a + b;
	b = a - b;
	a = a - b;*/

	//异或的方法
	a = a ^ b;//a = 6
	b = a ^ b;//b = 3
	a = a ^ b;//a = 5
	printf("after： a=%d b=%d\n",a,b);
	return 0;
}


练习:
    编写代码实现:求一个整数存储在内存中的二进制中1的个数

代码：
int main()
{
	int i = 0;
	int num = 0;
	int count = 0;
	scanf("%d", &num);
	for (i = 0; i < 32; i++)
	{
		if (1 == ((num >> i) & 1))
		{
			count++;
		}
	}
	printf("%d", count);


	//int num = 0;
	//int count = 0;
	//scanf("%d", &num);
	//while (num)
	//{
	//	if (num % 2 == 1)
	//	{
	//		count++;
	//		num = num / 2;
	//	}
	//}
	//printf("%d\n", count);
	return 0;
}



赋值操作符

赋值操作符是一个很棒的操作符，他可以让你得到一个你之前不满意的值。也就是你可以给自己重新赋
值。
int weight = 120;//体重
weight = 89;//不满意就赋值
double salary =10000.0;
salary = 20000.0;//使用赋值操作符赋值

赋值操作符可以连续使用，比如: 不建议这样写
int a = 10;
int x = 0;
int y = 20;
a = x = y+1;//连续赋值
这样的代码感觉怎么样?
那同样的语义，你看看:
x = y+1;
a = x;
这样的写法是不是更加清晰爽朗而且易于调试


复合赋值符
    分类：
        +=
        -=
        *=
        /=
        %=
        >>=
        <<=
        &=
        |=
        ^=
    这些运算符都可以写成复合的效果

    代码：
int main()
{
	int a = 10;
	a = a + 2;
	a += 2;//复合赋值符

	a = a >> 1;
	a >>= 1;

	a = a & 1;
	a &= 1;
	//都是等价的
	return 0;
}


单目操作符

    分类：
    ！ 逻辑反操作
    - 负值
    + 正值
    & 取地址
    sizeof 操作数的类型长度(以字节为单位)
    ~ 对一个数的二进制按位取反
    -- 前置、后置--
    ++ 前置、后置++
    * 间接访问操作符(解引用操作符)
    (类型) 强制类型转换

    ! 逻辑反操作:
int main()
{
	int a = 0;
	if (a)
	{
		printf("呵呵\n");
	}
	if (!a)
	{
		printf("呵呵\n");
	}
	//printf("%d\n", !a);//把真变成假，假变成真
	return 0;
}

    - 负值 + 正值：
int main()
{
	int a = -5; // - 负值
	a = -a;
    int b = 5;
    b = b;
	return 0;
}

    &取地址、* 解引用操作符：
int main()
{
	int a = 10;
	int* p = &a;//取地址操作符 一般和指针配合使用
	// p的指针变量
	*p = 20;//解引用操作符 找到他的位置 可以改他的值 用他的值 
	return 0;
}

    sizeof 操作数的类型长度(以字节为单位)：

int main()
{
	int a = 10;
	char c = 'r';
	char* p = &c;
	int arr[10] = { 0 };
	//sizeof 计算的变量所占内存空间的大小
	printf("%d\n", sizeof(a));//4
	printf("%d\n", sizeof(int));//4

	printf("%d\n", sizeof(c));//1
	printf("%d\n", sizeof(char));//1

	printf("%d\n", sizeof(p));//8 因为我是64位的电脑 所以是8  要是改成32位 就是 4了
	printf("%d\n", sizeof(char*));//8 因为我是64位的电脑 所以是8  要是改成32位 就是 4了

	printf("%d\n", sizeof(arr));//40
	printf("%d\n", sizeof(int [10]));//40 可以通过类型算大小 也可以通过变量算大小
}

补充：
int main()
{
	short s = 0;
	int a = 10;
	printf("%d\n", sizeof(s = a + 5));//这里面的a+5是一个摆设 他是不会去算的 2
	printf("%d\n", s);//0
	return 0;
}




~ 对一个数的二进制按位取反

代码：
int main()
{
	int a = 11;
	a = a | (1 << 2);
	printf("%d\n", a);//15
	a = a & (~(1 << 2));
	printf("%d\n", a);//11
	//00000000000000000000000000000001
	//11111111111111111111111111111011
	//00000000000000000000000000001111
	//00000000000000000000000000001011
	// 
	//00000000000000000000000000001011
	//00000000000000000000000000000100
	//1<<2;
	//00000000000000000000000000000001
	// 
	//00000000000000000000000000001011
	//int a = 0;
	//printf("%d\n", a);
	//  // ~ 按(2进制)位取反
	// //00000000000000000000000000000000
	////11111111111111111111111111111111 - 补码
	////11111111111111111111111111111110 - 反码
	////10000000000000000000000000000001 - 源码
	////-1
	//printf("%d\n", ~a);// -1

}

-- 前置、后置--  ++ 前置、后置：
代码：
int main()
{

	int a = 10;
	//printf("%d\n",++a);//前置++，先++，后使用 意思是 先加上 在去打印
	printf("%d\n", a++);//后置++，先使用，再++ 意思是 先打印 在加++
	return 0;
}


(类型) 强制类型转换：
代码：
int main()
{
	int a = (int)3.14;//强制类型转换
	printf("%d", a);
	return 0;
}


关系操作符：
	分类：
		>
		>=
		<
		<=
		!=	用于测试"不相等"
		==	用于测试"相等"
		这些关系运算符比较简单，没什么可将的，但是我们要注意一些运算符使用时候的陷阱
		警告 ： 在编程的过程中==和=不小心写错，导致的粗无。

逻辑操作符：
	分类：
	&&	逻辑与  并且的意思
	||	逻辑或  或者的意思

逻辑与和或的特点：
	360笔试题：
int main()
{
	int i = 0, a = 0, b = 2, c = 3, d = 4;
	//i = a++ && ++b && d++;//逻辑与&& 结果为什么是1234呢 因为a++是 后置++ 先使用后加加，先使用是 = 0的，
						 //逻辑与只要有一个为假，那后面的都不执行，再回来a++那就是a=1；
							//如果左边为假，右边的就不要算了
	i = a++ || ++b || d++;
							//逻辑|| 结果为什么是 1 3 3 4呢 因为||只要有一个是真 那么后面就不执行了 
							//左边如果为真，右边的那就不要算了
	printf("a = %d b = %d c = %d d = %d ", a, b, c, d);//逻辑与&&是1 2 3 4 逻辑或是||是1 3 3 4
	return 0;
	//程序的输出结果是什么？
}

条件操作符 exp1 ？ exp2 ：exp3 又称三目操作符

	练习：
int main()
{
	int a = 10;
	int b = 20;
	int max = 0;
	if (a > b)
		max = a;
	else
		max = b;

	max = (a > b ? a : b);//a如果大于b 条件为真执行a 条件为假执行b 
}


逗号表达式：
	exp1,exp2,exp3,...expn
	逗号表达式，就是用逗号隔开的多个表达式。逗号表达式，（从左向右依次执行）。
	整个表达式的结果是（最后一个表达式的结果）

	代码1：
int main()
{
	
	int a = 10;
	int b = 2;
	int c = (a > b, a = a + b, a, b = a + 1);//13 逗号表达式从左往右依次计算，结果是最后一个表达式
	printf("c = %d", c);
	return 0;
	//请问输出的结果是什么？
}

	代码2：
if(a=b+1，ca/2，d>0)

	代码3：
a = get_va1();
count_va1(a);
while (a>0)
{
	//业务处理
	a = get_va1();
	count_va1(a);
}

如果使用逗号表达式，改写while (a = get_va10，count_val(a)，a>0)；
{
	//业务处理
}



下标引用。函数调用和结构成员
1.[]下标引用操作符
操作数：一个数组名 + 一个索引值
	int arr[10];//创建数组
	arr[9]=10;//实用下标引用操作符

	代码：
int main()
{
	//操作数：一个数组名 + 一个索引值 a是数组名 [索引值]
	int a[10] = { 0 };//创建一个数组
	a[4] = 10;//a访问第五个元素 [他的下标是4] 然后赋值10
	return 0;
}

2.()函数调用操作符 接受一个或者多个操作数:第一个操作数是函数名，剩余的操作数就是传递给函数
的参数


代码：
int get_max(int x, int y)
{
	return x > y ? x : y;
}

int main()
{
	int a = 10;
	int b = 20;
	//调用函数的时候的()就是函数调用操作符
	int max = get_max(a, b);
	printf("%d", max);
	return 0;
}



3.访问一个结构的成员
	.  结构体.成员名 注：中间的点哦
	-> 结构体指针->成员名
	代码：
//学生
//int float 是类型
//
//创建一个结构体类型 - struct Stu
struct Stu
{
	char name[20];
	int age;
	char id[20];
};

int main()
{
	int a = 10;
	//使用struct stu这个类型创建了一个学生对象s1，并初始化
	struct Stu s1  = { "张三",17,"2022070111" };//s1 是变量
	struct Stu* ps = &s1;
	printf("%s\n", (ps->name));
	printf("%d\n", (ps->age));
	printf("%s\n", (ps->id));

	//printf("%s\n", (*ps).name);
	//printf("%d\n", (*ps).age);
	 
	//printf("%s\n", s1.name);
	//printf("%d\n", s1.age);
	//printf("%s\n", s1.id);
	//结构体变量.成员名
	return 0;
}


这里我们使用最普通的结构体，生成了一个结构体变量stu1

//实例1
struct stu {
	char* name;
	int num;
	int age;
	char group;
	float score;
};

int main() {
	//实例1
	struct stu stu1;
	stu1.name = "王令";
	stu1.num = 12;
	stu1.age = 18;
	stu1.group = 'A';
	stu1.score = 137.0;
	printf("%s的学号是%d,年龄是%d,在%c组,今年的成绩是%.lf!\n",
		stu1.name, stu1.num, stu1.age, stu1.group, stu1.score);
	return 0;
}


//实例2
typedef struct stu //typedef 来修饰结构体加了这个然后定义一个别名就可以像 int 和 double 那样直接使用 Stu 定义变量
{
	char* name;
	int num;
	int age;
	char group;
	float score;
}Stu;//这里的Stu是结构体别名

int main() {
	//实例1的声明 
	//struct stu stu1;
	//实例2的声明 
	Stu stu1;
	Stu stu2;
	stu1.name = "elephant111";
	stu1.num = 12;
	stu1.age = 18;
	stu1.group = 'A';
	stu1.score = 137.0;
	printf("%s的学号是%d,年龄是%d,在%c组,今年的成绩是%.lf!\n",
		stu1.name, stu1.num, stu1.age, stu1.group, stu1.score);
	stu2.name = "elephant222";
	stu2.num = 13;
	stu2.age = 19;
	stu2.group = 'B';
	stu2.score = 136.0;
	printf("%s的学号是%d,年龄是%d,在%c组,今年的成绩是%.lf!\n",
		stu2.name, stu2.num, stu2.age, stu2.group, stu2.score);
	return 0;
}



//struct 与 typedef 分开定义，如下面的代码所示：
typedef struct tagNode* pNode;//pNode是结构体别名
struct tagNode
{
	char* pItem;
	pNode pNext;
};





表达式求值：

	表达式求值的顺序一部分是由操作符的优先级和结合性决定

	同样，有些表达式的操作数在求值的过程中可能需要转换为其他类型

隐式类型转换：

	C的整型算术运算总是至少以缺省整型类型的精度来进行的
	为了获得这个精度，表达式中的字符和短整型操作数在使用之前被转换为普通整型，这种转换称为整型
	提升。
	整型提升的意义：
		 表达式的整型运算要在CPU的相应运算器件内执行，CPU内整型运算器(ALU)的操作数的字节长度
		 一般就是int的字节长度，同时也是CPU的通用存器的长度。
		 因此，即使两个ar类型的相加，在CPU执行时实际上也要先转换为CPU内整型操作数的标准长
		 度。
		 通用CPU(general-purposeCPU)是难以直接实现两个8比特字节直接相加运算(虽然机器指令
		 中可能有这种字节相加指令)。所以，表达式中各种长度可能小于int长度的整型值，都必须先转
		 换为int或unsignedint，然后才能送入CPU去执行运算

代码：
int main()
{
	char a = 3;
	//00000000000000000000000000000011
	//00000011 - a  为什么取8位呢 因为char类型是1个字节 1个字节等于8个比特位 所以要截断
	char b = 127;
	//00000000000000000000000001111111
	//01111111 - b 同上

	//a和b如何相加
	//00000000000000000000000000000011 - a
	//00000000000000000000000001111111 - b
	// +3
	//00000000000000000000000010000010 - c
	char c = a + b;
	//10000010 - c
	//11111111111111111111111110000010 - 补码
	//11111111111111111111111110000011 - 反码
	//10000000000000000000000001111100 - 原码
	//-126 存储的是原码
	printf("%d", c);
	return 0;
}
	b和c的值被提升为普通整型，然后再执行加法运算
	法运算完成之后，结果将被截断，然后再存储于a中

	如何进行整体提升呢?
		整形提升是按照变量的数据类型的符号位来提升的

		//负数的整形提升
		char c1 = -1;
		交量c1的二进制位(补码)中只有8个比特位:
		1111111
		因为 char 为有符号的 char
		所以整形提升的时候，高位补充符号位，即为1
		提升之后的结果是:
		11111111111111111111111111111111

		//正数的整形提升
		char c2 = 1;
		变量c2的二进制位(补码)中有8个比特位
		00000001
		因为char 为有符号的dar
		所以整形提升的时候，高位补充符号位，即为0
		提升之后的结果是:
		0000000000000000000000000000001

		//无符号整形提升，高位补0

		/实例1
int main
{
	char a = 0xb6;
	short b = 0xb600;
	int c = 0xb6000000:
	if(a==0xb6)
		printf("a");
	if(b==0xb600)
		printf("b");
	if(c==0xb6000000)
		printf("c");
	return 0;
}

	实例1中的a b要进行整形提升但是不需要整形提升
	ab整形提升之后,变成了负数,所以表达式a==0xb6,b==0xb600的结里是假但是c不发生整形提升则表达式
	c==0xb6000000的结果是真

	//实例2
int main
{
	char c= 1
	printf("%u\n",sizeof(c));
	printf("%u\n",sizeof(+c));
	printf("%u\n",sizeof(!c));
	return0:
}
	实例2中的,c只要参与表达式运算,就会发生整形提升,表达式+c就会发生提升所以sizeof(+c)是4个字
	节
	表达式-c也会发生整形提升所以sizeof(-c)是4个字节但是sizeof(c)就是1个字节

算术转换：

	如果某个操作符的各个操作数属于不同的类型，那么除非其中一个操作数的转换为另一个操作数的类
	型，否则操作就无法进行。下面的层次体系称为寻常算术转换。

		long double
		double
		float
		unsigned long int
		long tnt
		unsigned int
		int
	如果某个操作数的类型在上面这个列表中排名较低，那么首先要转换为另外一个操作数的类型后执行运算

	警告:但是算术转换要合理，要不然会有一些潜在的问题。

操作符的属性：

复杂表达式的求值有三个影响的因素。
1.操作符的优先级
2.操作符的结合性
3.是否控制求值顺序
两个相邻的操作符先执行哪个?取决于他们的优先级。如果两者的优先级相同，取决于他们的结合性.操作符优先级

一些问题表达式(有问题的表达式)！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
	表达式的求值部分由操作符的优先级决定。
	表达式1
	a*b + c*d + e*f
	注释:代码1在计算的时候，由于的优先级高，只能保证的计算是比+早，但是优先级井不
	能决定第三个*比第一个早执行

	所以表达式的计算机顺序就可能是
		a*b
		c*d
		a*b + c*d
		e*f
		a*b + c*d + e*f

		或者：
		a*b
		c*d 
		e*f


	表达式2
	c + --c;  //假如--c之前就准备好，c自减，之前准备好的就从1变为0
	注释，同上，操作符的优先级只能决定减-的运算在+的运算的前面，但是我们并没有办法得
	知，+操作符的左操作数的获取在右操作数之前还是之后求值，所以结果是不可预测的，是有歧义
	的



	总结，表达式的计算路径要唯一，不然就是错误表达式